package aip.migrate;import aip.db.AIPDBColumn;import aip.db.AIPDBTable;import aip.db.AIPDBUtil;import aip.util.AIPException;import aip.util.AIPTransfer;import aip.util.AIPUtil;import aip.util.DateConvert;import aip.util.NVL;import java.io.File;import java.io.FileFilter;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStreamReader;import java.io.PrintStream;import java.io.PrintWriter;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Comparator;import java.util.Date;import java.util.HashSet;import java.util.List;import java.util.Properties;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NodeList;public class AIPMigrate{  private static final int defaultBatchLength = 1000;  private static final int defaultTransferPrintLength = 100;  private static final String defaultPK = "id";  static String aipmigrate_config_filename = "aipmigrate.cfg";  private static final String defaultCnvCharsSrc = "٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹یک'\"\f";  private static final String defaultCnvCharsDest = "01234567890123456789يك   ";    public static void main(String[] args)  {    try    {      AIPMigrate aipMigrate = new AIPMigrate();      AIPMigrateArgs migrateArgs = parsMeigrateArgs(args);      if ((!migrateArgs.isIsgenerate()) && (!migrateArgs.isIsmigrate()) && (!migrateArgs.isIsvalidate())) {        System.out.println("AIPMigrate syntax:\n\t java AIPMigrate => print this message and validate " + aipmigrate_config_filename + " check connections.\n" + "\t java AIPMigrate -generate lw% => generate lw%.aipmigrate.xml for all lw% tables in source connection.\n" + "\t java AIPMigrate -migrate  lw% => migrate all lw% tables from source to dest that mapping located in lw%.aipmigrate.xml files and log in aipmigrate[date][time].log file and before migrate validate them.\n" + "\t java AIPMigrate -migrate  lw% -logging log.txt => migrate all lw% tables from source to dest that mapping located in lw%.aipmigrate.xml files and log in log.txt file  and before migrate validate them.\n" + "\t java AIPMigrate -validate lw% => validate all lw%.aipmigrate.xml files tables and columns.\n" + "\t java AIPMigrate -path aipmigrate => locate lw%.aipmigrate.xml files in aipmigrate path.\n" + "\n");      }      aipMigrate.check_aipmigrate_config_exist_validate_or_create();            AIPMigrateConfig migrateConfig = aipMigrate.load_aipmigrate_config();      if (migrateArgs.isIspath()) {        migrateConfig.setPath(migrateArgs.getPath());      }      if (migrateArgs.isIsgenerate()) {        aipMigrate.generate(migrateConfig, migrateArgs.getGenerate());      }      if (migrateArgs.isIsvalidate()) {        aipMigrate.validate(migrateConfig, migrateArgs.getValidate());      }      if (migrateArgs.isIsmigrate())      {        aipMigrate.validate(migrateConfig, migrateArgs.getMigrate());        aipMigrate.migrate(migrateConfig, migrateArgs.getMigrate(), migrateArgs.getLogging());      }    }    catch (Exception e)    {      System.out.println("main():exception=" + e.getMessage());      e.printStackTrace(System.out);    }    System.out.flush();    System.err.flush();  }    private void generate(AIPMigrateConfig migrateConfig, String tables_filter)    throws Exception  {    System.out.println("generate(" + tables_filter + "):start....");        List<AIPDBTable> tables = AIPDBUtil.getDBTables(migrateConfig.getSrcDriver(), migrateConfig.getSrcURL(), migrateConfig.getSrcUser(), migrateConfig.getSrcPass(), NVL.getStringNull(tables_filter.toUpperCase()));    for (int i = 0; i < tables.size(); i++) {      generateTableMigrateXML(migrateConfig, (AIPDBTable)tables.get(i));    }    System.out.println("generate():end.");  }    private void generateTableMigrateXML(AIPMigrateConfig migrateConfig, AIPDBTable table)    throws Exception  {    System.out.println("generateTableMigrateXML(" + table.getTablename() + "):start....");        List<AIPDBColumn> columns = table.getColumns();        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();    DocumentBuilder docBuilder = docFactory.newDocumentBuilder();        Document doc = docBuilder.newDocument();        Element rootElement = doc.createElement("table");    doc.appendChild(rootElement);        Attr tablename = doc.createAttribute("tablename");    tablename.setValue(table.getTablename());    rootElement.setAttributeNode(tablename);        Attr hasLOB = doc.createAttribute("hasLOB");    hasLOB.setValue("false");    rootElement.setAttributeNode(hasLOB);        int dbtype = 0;    if (migrateConfig.getDestDriver().toUpperCase().indexOf("ORACLE") > -1) {      dbtype = 1;    }    Attr destdbtype = doc.createAttribute("destdbtype");    destdbtype.setValue("" + dbtype);    rootElement.setAttributeNode(destdbtype);        Attr srcQuery = doc.createAttribute("srcQuery");    srcQuery.setValue("select * from " + table.getTablename());    rootElement.setAttributeNode(srcQuery);        Attr destSQL = doc.createAttribute("destSQL");    destSQL.setValue(AIPDBUtil.getInsertSQL(table, dbtype));    rootElement.setAttributeNode(destSQL);        Attr checkExist = doc.createAttribute("checkExist");    checkExist.setValue("true");    rootElement.setAttributeNode(checkExist);        Attr checkExistQuery = doc.createAttribute("checkExistQuery");    checkExistQuery.setValue("select id from " + table.getTablename() + " where id=:id");    rootElement.setAttributeNode(checkExistQuery);        Attr existSQLEnable = doc.createAttribute("existSQLEnable");    existSQLEnable.setValue("false");    rootElement.setAttributeNode(existSQLEnable);        Attr existSQL = doc.createAttribute("existSQL");    existSQL.setValue(AIPDBUtil.getUpdateSQL(table));    rootElement.setAttributeNode(existSQL);        Attr beforeMigrateExecOnSrc = doc.createAttribute("beforeMigrateExecOnSrc");    beforeMigrateExecOnSrc.setValue("");    rootElement.setAttributeNode(beforeMigrateExecOnSrc);        Attr beforeMigrateExecOnDest = doc.createAttribute("beforeMigrateExecOnDest");    beforeMigrateExecOnDest.setValue("");    rootElement.setAttributeNode(beforeMigrateExecOnDest);        Attr batchLength = doc.createAttribute("batchLength");    batchLength.setValue("1000");    rootElement.setAttributeNode(batchLength);        Attr transferPrintLength = doc.createAttribute("transferPrintLength");    transferPrintLength.setValue("100");    rootElement.setAttributeNode(transferPrintLength);        Attr pk = doc.createAttribute("pk");    pk.setValue("id");    rootElement.setAttributeNode(pk);        Attr destClobClause = doc.createAttribute("destClobClause");    destClobClause.setValue("");    rootElement.setAttributeNode(destClobClause);    for (int i = 0; i < columns.size(); i++)    {      String columntype = ((AIPDBColumn)columns.get(i)).getColumntype().toUpperCase();      if ((columntype.indexOf("LOB") > -1) || (columntype.indexOf("TEXT") > -1))      {        hasLOB.setValue("true");                Element column_lob = doc.createElement("column_lob");                Attr column_src = doc.createAttribute("column_src");        column_src.setValue(((AIPDBColumn)columns.get(i)).getColumnname());        column_lob.setAttributeNode(column_src);                Attr column_dest = doc.createAttribute("column_dest");        column_dest.setValue(((AIPDBColumn)columns.get(i)).getColumnname());        column_lob.setAttributeNode(column_dest);                rootElement.appendChild(column_lob);      }      else      {        Element column = doc.createElement("column");                Attr column_src = doc.createAttribute("column_src");        column_src.setValue(((AIPDBColumn)columns.get(i)).getColumnname());        column.setAttributeNode(column_src);                Attr column_dest = doc.createAttribute("column_dest");        column_dest.setValue(":" + ((AIPDBColumn)columns.get(i)).getColumnname());        column.setAttributeNode(column_dest);                rootElement.appendChild(column);      }    }    TransformerFactory transformerFactory = TransformerFactory.newInstance();    Transformer transformer = transformerFactory.newTransformer();    DOMSource source = new DOMSource(doc);    File aipmigratefile;    if (NVL.isEmpty(migrateConfig.getPath()))    {      aipmigratefile = new File(table.getTablename().toLowerCase() + ".aipmigrate.xml");    }    else    {      File parent = new File(migrateConfig.getPath());      if (!parent.exists()) {        parent.mkdirs();      }      aipmigratefile = new File(parent, table.getTablename().toLowerCase() + ".aipmigrate.xml");    }    StreamResult result = new StreamResult(aipmigratefile);    transformer.transform(source, result);        System.out.println("generateTableMigrateXML():end.");  }    private void validate(AIPMigrateConfig migrateConfig, String xmlfiles_filter)    throws Exception  {    System.out.println("validate(" + xmlfiles_filter + "):start....");        File[] files = list_xmlfiles(NVL.getString(migrateConfig.getPath()), xmlfiles_filter);    if (files.length == 0) {      System.out.println("validate():file not found! with filter " + xmlfiles_filter + " in path " + NVL.getString(migrateConfig.getPath()));    }    for (int i = 0; i < files.length; i++) {      validateXMLFile(migrateConfig, files[i]);    }    System.out.println("validate():end.");  }    private void validateXMLFile(AIPMigrateConfig migrateConfig, File migrateXMLfile)    throws Exception  {    System.out.println("validateXMLFile(" + migrateXMLfile + "):start.....");        AIPMigrateXMLInfo migrateXMLInfo = load_migrate_xmlfile(migrateXMLfile);        List<AIPDBTable> src_tables = AIPDBUtil.getDBTables(migrateConfig.getSrcDriver(), migrateConfig.getSrcURL(), migrateConfig.getSrcUser(), migrateConfig.getSrcPass(), migrateXMLInfo.getTablename());    if (src_tables.size() == 0) {      throw new Exception("[" + migrateXMLInfo.getTablename() + "] source table in " + migrateConfig.getSrcURL() + " does not exist!");    }    AIPDBTable src_table = (AIPDBTable)src_tables.get(0);        List<AIPDBTable> dest_tables = AIPDBUtil.getDBTables(migrateConfig.getDestDriver(), migrateConfig.getDestURL(), migrateConfig.getDestUser(), migrateConfig.getDestPass(), migrateXMLInfo.getTablename().toUpperCase());    if (dest_tables.size() == 0) {      throw new Exception("[" + migrateXMLInfo.getTablename() + "] destination table in " + migrateConfig.getDestURL() + " does not exist!");    }    AIPDBTable dest_table = (AIPDBTable)dest_tables.get(0);    for (int i = 0; i < migrateXMLInfo.getColumns().size(); i++)    {      AIPMigrateXMLColumn column_xml = (AIPMigrateXMLColumn)migrateXMLInfo.getColumns().get(i);            boolean src_column_found = false;      for (int j = 0; (j < src_table.getColumns().size()) && (!src_column_found); j++)      {        AIPDBColumn column_db = (AIPDBColumn)src_table.getColumns().get(j);        if (column_xml.getColumn_src().equalsIgnoreCase(column_db.getColumnname())) {          src_column_found = true;        }      }      if (!src_column_found) {        throw new Exception("[" + column_xml.getColumn_src() + "] source column in [" + migrateXMLInfo.getTablename() + "] table in " + migrateConfig.getSrcURL() + " does not exist!");      }      boolean dest_column_found = false;      String column_dest = column_xml.getColumn_dest().replaceAll(":", "");      for (int j = 0; (j < dest_table.getColumns().size()) && (!dest_column_found); j++)      {        AIPDBColumn column_db = (AIPDBColumn)dest_table.getColumns().get(j);        if (column_dest.equalsIgnoreCase(column_db.getColumnname())) {          dest_column_found = true;        }      }      if (!dest_column_found)      {        StringBuffer sb_destcolumns = new StringBuffer();        for (int j = 0; j < dest_table.getColumns().size(); j++)        {          sb_destcolumns.append(((AIPDBColumn)dest_table.getColumns().get(j)).getColumnname());          sb_destcolumns.append(" ,");        }        throw new Exception("[" + column_dest + "] destination column in [" + migrateXMLInfo.getTablename() + "] table in " + migrateConfig.getDestURL() + " does not exist!.\n dest columns are:\n" + sb_destcolumns.toString());      }    }    System.out.println("validateXMLFile():end.");  }    private void migrate(AIPMigrateConfig migrateConfig, String xmlfiles_filter, String logging_file)  {    System.out.println("migrate(" + xmlfiles_filter + "):start...");    Date method_start = new Date();        PrintStream logging = null;    try    {      if (NVL.isEmpty(logging_file)) {        logging_file = "aipmigrate-" + DateConvert.getTodayJalali().replaceAll("/", "") + "-" + DateConvert.getTime().replaceAll(":", "") + ".log";      }      File logging_path = new File(logging_file);      if (!logging_path.exists()) {        logging_path.getParentFile().mkdirs();      }      logging = new PrintStream(new FileOutputStream(logging_path, true));    }    catch (Exception e)    {      System.err.println("Error Logging File:exception=" + e.getMessage());      e.printStackTrace();      System.exit(0);    }    File[] files = list_xmlfiles(NVL.getString(migrateConfig.getPath()), xmlfiles_filter);    if (files.length == 0) {      System.out.println("migrate():file not found! with filter " + xmlfiles_filter + " in path " + NVL.getString(migrateConfig.getPath()));    }    for (int i = 0; i < files.length; i++) {      migrateTable(migrateConfig, files[i], logging);    }    Date method_end = new Date();    System.out.println("migrate():end:time=" + (method_end.getTime() - method_start.getTime()) / 1000L + " seconds.");  }    private void migrateTable(AIPMigrateConfig config, File migrateXMLfile, PrintStream logging)  {    System.out.println("migrateTable(" + migrateXMLfile.getName() + "):start...");    Date method_start = new Date();    try    {      AIPMigrateXMLInfo migrateXMLInfo = load_migrate_xmlfile(migrateXMLfile);            String existSQL = migrateXMLInfo.isExistSQLEnable() ? migrateXMLInfo.getExistSQL() : null;            AIPTransfer transfer = new AIPTransfer();            transferDataSimple(config, migrateXMLInfo, logging);      if (migrateXMLInfo.isHasLOB()) {        transferDataClob(config, migrateXMLInfo, logging);      }    }    catch (Exception e)    {      System.out.println("migrateTable():exception=" + e.getMessage());      e.printStackTrace();    }    Date method_end = new Date();    System.out.println("migrateTable():end:time=" + (method_end.getTime() - method_start.getTime()) / 1000L + " seconds.");  }    private AIPMigrateXMLInfo load_migrate_xmlfile(File migrateXMLfile)    throws Exception  {    AIPMigrateXMLInfo migrateXMLInfo = new AIPMigrateXMLInfo();    DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();    Document doc = dBuilder.parse(migrateXMLfile);    doc.getDocumentElement().normalize();        Element tableNode = doc.getDocumentElement();    if (!tableNode.getTagName().equalsIgnoreCase("table")) {      throw new Exception(migrateXMLfile + " root element should be <table ...");    }    migrateXMLInfo.setTablename(tableNode.getAttribute("tablename"));        migrateXMLInfo.setCheckExist(NVL.getBool(tableNode.getAttribute("checkExist")));    migrateXMLInfo.setHasLOB(NVL.getBool(tableNode.getAttribute("hasLOB")));    migrateXMLInfo.setDestdbtype(NVL.getInt(tableNode.getAttribute("destdbtype")));        migrateXMLInfo.setSrcQuery(tableNode.getAttribute("srcQuery"));    migrateXMLInfo.setDestSQL(tableNode.getAttribute("destSQL"));    migrateXMLInfo.setCheckExistQuery(tableNode.getAttribute("checkExistQuery"));    migrateXMLInfo.setExistSQL(tableNode.getAttribute("existSQL"));    migrateXMLInfo.setExistSQLEnable(NVL.getBool(tableNode.getAttribute("existSQLEnable")));        migrateXMLInfo.setBeforeMigrateExecOnSrc(NVL.getString(tableNode.getAttribute("beforeMigrateExecOnSrc")));        migrateXMLInfo.setBeforeMigrateExecOnDest(NVL.getString(tableNode.getAttribute("beforeMigrateExecOnDest")));        migrateXMLInfo.setBatchLength(NVL.getInt(tableNode.getAttribute("batchLength"), 1000));        migrateXMLInfo.setTransferPrintLength(NVL.getInt(tableNode.getAttribute("transferPrintLength"), 100));        migrateXMLInfo.setPk(NVL.getStringEmpty(tableNode.getAttribute("pk"), "id"));        migrateXMLInfo.setDestClobClause(NVL.getString(tableNode.getAttribute("destClobClause")));    for (int i = 0; i < tableNode.getChildNodes().getLength(); i++)    {      Element column = (Element)tableNode.getChildNodes().item(i);      AIPMigrateXMLColumn migrateXMLColumn = new AIPMigrateXMLColumn();      migrateXMLColumn.setColumn_src(column.getAttribute("column_src"));      migrateXMLColumn.setColumn_dest(column.getAttribute("column_dest"));      if ("column_lob".equalsIgnoreCase(column.getTagName())) {        migrateXMLColumn.setIslob(true);      }      migrateXMLInfo.getColumns().add(migrateXMLColumn);    }    return migrateXMLInfo;  }    private void transferDataSimple(AIPMigrateConfig config, AIPMigrateXMLInfo migrateXMLInfo, PrintStream prntStream)  {    System.out.println("AIPMigrate.transferDataSimple():Starting.......");    Date method_start = new Date();        Connection srcCN = null;Connection destCN = null;    Statement srcSTMT = null;Statement destSTMT = null;Statement destSTMTExist = null;    ResultSet srcRS = null;ResultSet destRS = null;    String tmpSQL = null;    String tmpExists = null;    String tmpAlternate = null;    try    {      String srcQuery = migrateXMLInfo.getSrcQuery().toLowerCase();      if (migrateXMLInfo.isHasLOB())      {        String src_columns = AIPUtil.joinSelectedIds(migrateXMLInfo.getSrcColumns(), ",");        srcQuery = AIPUtil.replaceAllString(srcQuery, " * ", " " + src_columns + " ");      }      String destSQL = migrateXMLInfo.getDestSQL().toLowerCase();      String ifExistsNoAlternateSQL = migrateXMLInfo.getExistSQL().toLowerCase();      String[] srcColumns = new String[migrateXMLInfo.getSrcColumns().length];      for (int i = 0; i < srcColumns.length; i++) {        srcColumns[i] = migrateXMLInfo.getSrcColumns()[i].toLowerCase();      }      String[] destColumns = new String[migrateXMLInfo.getDestColumns().length];      for (int i = 0; i < destColumns.length; i++) {        destColumns[i] = migrateXMLInfo.getDestColumns()[i].toLowerCase();      }      Class.forName(config.getSrcDriver());      srcCN = DriverManager.getConnection(config.getSrcURL(), config.getSrcUser(), config.getSrcPass());      srcSTMT = srcCN.createStatement(1003, 1007);            Class.forName(config.getDestDriver());      destCN = DriverManager.getConnection(config.getDestURL(), config.getDestUser(), config.getDestPass());      destSTMT = destCN.createStatement();      String ifExistsNoActionQuery = migrateXMLInfo.getCheckExistQuery();      if (ifExistsNoActionQuery != null)      {        ifExistsNoActionQuery = ifExistsNoActionQuery.toLowerCase();        destSTMTExist = destCN.createStatement(1003, 1007);      }      if (!NVL.isEmpty(migrateXMLInfo.getTablename())) {        try        {          long tablecount = AIPDBUtil.getDBTableCount(srcCN, migrateXMLInfo.getTablename(), null);          System.out.print("table count=" + tablecount);        }        catch (Exception e)        {          System.out.println("table count:exception=" + e.getMessage());        }      }      if (!NVL.isEmpty(migrateXMLInfo.getBeforeMigrateExecOnSrc())) {        try        {          Statement stmtBeforeMigrateExecOnSrc = srcCN.createStatement();          String[] sqls = AIPUtil.splitSelectedIds(migrateXMLInfo.getBeforeMigrateExecOnSrc(), ";");          for (int i = 0; i < sqls.length; i++) {            stmtBeforeMigrateExecOnSrc.addBatch(sqls[i]);          }          stmtBeforeMigrateExecOnSrc.executeBatch();          stmtBeforeMigrateExecOnSrc.close();        }        catch (Exception e)        {          System.out.println("BeforeMigrateExecOnSrc=" + migrateXMLInfo.getBeforeMigrateExecOnSrc());          System.out.println("AIPMigrate.transferData():exception=" + e.getMessage());          if (prntStream != null) {            prntStream.println("BeforeMigrateExecOnSrc=" + migrateXMLInfo.getBeforeMigrateExecOnSrc() + "\n\t exception=" + e.getMessage());          }        }      }      if (!NVL.isEmpty(migrateXMLInfo.getBeforeMigrateExecOnDest())) {        try        {          Statement stmtBeforeMigrateExecOnDest = destCN.createStatement();          String[] sqls = AIPUtil.splitSelectedIds(migrateXMLInfo.getBeforeMigrateExecOnDest(), ";");          for (int i = 0; i < sqls.length; i++) {            stmtBeforeMigrateExecOnDest.addBatch(sqls[i]);          }          stmtBeforeMigrateExecOnDest.executeBatch();          stmtBeforeMigrateExecOnDest.close();        }        catch (Exception e)        {          System.out.println("beforeMigrateExecOnDest=" + migrateXMLInfo.getBeforeMigrateExecOnDest());          System.out.println("AIPMigrate.transferData():exception=" + e.getMessage());          if (prntStream != null) {            prntStream.println("beforeMigrateExecOnDest=" + migrateXMLInfo.getBeforeMigrateExecOnDest() + "\n\t exception=" + e.getMessage());          }        }      }      boolean batch_enabled = false;      int batch_length = migrateXMLInfo.getBatchLength();      if (batch_length > 1) {        batch_enabled = true;      }      int batch_counter = 0;            ArrayList<String> batch_tmpSQL = new ArrayList();            int transfer_print_all = 0;      int transfer_print_counter = 0;      int transfer_print_length = migrateXMLInfo.getTransferPrintLength();      if (transfer_print_length > 0) {        System.out.print("\t transfer_print:");      }      int exits_count = 0;            Collection<String> destExistPKs = new HashSet();      if (!migrateXMLInfo.isExistSQLEnable()) {        destExistPKs = AIPDBUtil.getDBTablePKs(config.getDestDriver(), config.getDestURL(), config.getDestUser(), config.getDestPass(), migrateXMLInfo.getTablename(), migrateXMLInfo.getPk());      }      srcRS = srcSTMT.executeQuery(srcQuery);      while (srcRS.next())      {        if (!migrateXMLInfo.isExistSQLEnable())        {          String srcPk = srcRS.getString(migrateXMLInfo.getPk());          if (destExistPKs.contains(srcPk))          {            exits_count++;            transfer_print_counter++;            if ((transfer_print_length <= 0) || (transfer_print_counter <= 0) || (transfer_print_counter % transfer_print_length != 0)) {              continue;            }            System.out.print(",");            transfer_print_all += transfer_print_counter;            System.out.print(transfer_print_all);            transfer_print_counter = 0; continue;          }        }        tmpSQL = destSQL;        tmpExists = ifExistsNoActionQuery;        tmpAlternate = ifExistsNoAlternateSQL;        for (int i = 0; i < destColumns.length; i++)        {          String value = NVL.getString(srcRS.getString(srcColumns[i]), "null");                    value = AIPUtil.cnvCharsSrc2Dest(value, config.getCnvCharsSrc(), config.getCnvCharsDest());                    tmpSQL = tmpSQL.replaceAll(destColumns[i], value);          if (tmpExists != null) {            tmpExists = tmpExists.replaceAll(destColumns[i], value);          }          if (tmpAlternate != null) {            tmpAlternate = tmpAlternate.replaceAll(destColumns[i], value);          }        }        boolean doAction = true;        if (tmpExists != null) {          try          {            destRS = destSTMTExist.executeQuery(tmpExists);            if (destRS.next()) {              if ((tmpAlternate != null) && (migrateXMLInfo.isExistSQLEnable()))              {                tmpSQL = tmpAlternate;              }              else              {                doAction = false;                exits_count++;              }            }            destRS.close();          }          catch (Exception e)          {            System.out.println("tmpExists=" + tmpExists);            System.out.println("AIPMigrate.transferData():exception=" + e.getMessage());            if (prntStream != null) {              prntStream.println("tmpExists=" + tmpExists + "\n\t exception=" + e.getMessage());            }          }        }        if (doAction)        {          tmpSQL = tmpSQL.replaceAll("'null'", "null");          tmpSQL = tmpSQL.replaceAll("''", "' '");          try          {            if (batch_enabled)            {              destSTMT.addBatch(tmpSQL);              batch_counter++;              transfer_print_counter++;              batch_tmpSQL.add(tmpSQL);              if (batch_counter >= batch_length)              {                destSTMT.executeBatch();                batch_counter = 0;                batch_tmpSQL.clear();              }            }            else            {              destSTMT.executeUpdate(tmpSQL);              transfer_print_counter++;            }          }          catch (Exception e)          {            if (batch_enabled)            {              destSTMT.clearBatch();              for (int i = 0; i < batch_tmpSQL.size(); i++) {                try                {                  destSTMT.executeUpdate((String)batch_tmpSQL.get(i));                }                catch (Exception e2)                {                  System.out.println("tmpSQL=" + (String)batch_tmpSQL.get(i) + "\n\t exception=" + e2.getMessage());                  if (prntStream != null) {                    prntStream.println(tmpSQL + "\n\t exception=" + e2.getMessage());                  }                }              }              batch_counter = 0;              batch_tmpSQL.clear();            }            else            {              System.out.println("tmpSQL=" + tmpSQL + "\n\t exception=" + e.getMessage());              if (prntStream != null) {                prntStream.println(tmpSQL + "\n\t exception=" + e.getMessage());              }            }            System.out.println("AIPMigrate.transferData():exception=" + e.getMessage());          }        }        else        {          transfer_print_counter++;        }        if ((transfer_print_length > 0) && (transfer_print_counter > 0) && (transfer_print_counter % transfer_print_length == 0))        {          System.out.print(",");          transfer_print_all += transfer_print_counter;          System.out.print(transfer_print_all);          transfer_print_counter = 0;                    System.gc();          Runtime.getRuntime().gc();        }      }      if ((batch_enabled) && (batch_counter > 0)) {        try        {          destSTMT.executeBatch();                    System.out.print(",");          transfer_print_all += transfer_print_counter;          System.out.print(transfer_print_all);          System.out.print("\n");        }        catch (Exception e)        {          destSTMT.clearBatch();          for (int i = 0; i < batch_tmpSQL.size(); i++) {            try            {              destSTMT.executeUpdate((String)batch_tmpSQL.get(i));            }            catch (Exception e2)            {              System.out.println("tmpSQL=" + (String)batch_tmpSQL.get(i) + "\n\t exception=" + e2.getMessage());              if (prntStream != null) {                prntStream.println(tmpSQL + "\n\t exception=" + e2.getMessage());              }            }          }          batch_counter = 0;          batch_tmpSQL.clear();        }      }      System.out.println(",exits_count=" + exits_count);    }    catch (Exception e)    {      System.out.println("tmpSQL=" + tmpSQL + "\n\t exception=" + e.getMessage());      if (prntStream != null) {        prntStream.println(tmpSQL + "\n\t exception=" + e.getMessage());      }      System.out.println("AIPMigrate.transferData():exception=" + e.getMessage());    }    finally    {      try      {        if (srcRS != null) {          srcRS.close();        }        if (destRS != null) {          destRS.close();        }        if (srcSTMT != null) {          srcSTMT.close();        }        if (destSTMT != null) {          destSTMT.close();        }        if (destSTMTExist != null) {          destSTMTExist.close();        }        if (srcCN != null) {          srcCN.close();        }        if (destCN != null) {          destCN.close();        }      }      catch (Exception e2)      {        System.out.println("AIPMigrate.transferData():exception=" + e2.getMessage());      }    }    System.gc();    Runtime.getRuntime().gc();        Date method_end = new Date();    System.out.println("AIPMigrate.transferDataSimple():end:time=" + (method_end.getTime() - method_start.getTime()) / 1000L + " seconds.");  }    /* Error */  private void transferDataClob(AIPMigrateConfig config, AIPMigrateXMLInfo migrateXMLInfo, PrintStream prntStream)  {    // Byte code:    //   0: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   3: ldc_w 302    //   6: invokevirtual 22	java/io/PrintStream:println	(Ljava/lang/String;)V    //   9: new 163	java/util/Date    //   12: dup    //   13: invokespecial 164	java/util/Date:<init>	()V    //   16: astore 4    //   18: aconst_null    //   19: astore 5    //   21: aconst_null    //   22: astore 6    //   24: aconst_null    //   25: astore 7    //   27: aconst_null    //   28: astore 8    //   30: aconst_null    //   31: astore 9    //   33: aconst_null    //   34: astore 10    //   36: aload_1    //   37: invokevirtual 43	aip/migrate/AIPMigrateConfig:getSrcDriver	()Ljava/lang/String;    //   40: invokestatic 245	java/lang/Class:forName	(Ljava/lang/String;)Ljava/lang/Class;    //   43: pop    //   44: aload_1    //   45: invokevirtual 44	aip/migrate/AIPMigrateConfig:getSrcURL	()Ljava/lang/String;    //   48: aload_1    //   49: invokevirtual 45	aip/migrate/AIPMigrateConfig:getSrcUser	()Ljava/lang/String;    //   52: aload_1    //   53: invokevirtual 46	aip/migrate/AIPMigrateConfig:getSrcPass	()Ljava/lang/String;    //   56: invokestatic 246	java/sql/DriverManager:getConnection	(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/Connection;    //   59: astore 5    //   61: aload 5    //   63: sipush 1003    //   66: sipush 1007    //   69: invokeinterface 247 3 0    //   74: astore 7    //   76: aload_1    //   77: invokevirtual 70	aip/migrate/AIPMigrateConfig:getDestDriver	()Ljava/lang/String;    //   80: invokestatic 245	java/lang/Class:forName	(Ljava/lang/String;)Ljava/lang/Class;    //   83: pop    //   84: new 303	java/util/Properties    //   87: dup    //   88: invokespecial 304	java/util/Properties:<init>	()V    //   91: astore 11    //   93: aload 11    //   95: ldc_w 305    //   98: aload_1    //   99: invokevirtual 142	aip/migrate/AIPMigrateConfig:getDestUser	()Ljava/lang/String;    //   102: invokevirtual 306	java/util/Properties:setProperty	(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;    //   105: pop    //   106: aload 11    //   108: ldc_w 307    //   111: aload_1    //   112: invokevirtual 143	aip/migrate/AIPMigrateConfig:getDestPass	()Ljava/lang/String;    //   115: invokevirtual 306	java/util/Properties:setProperty	(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;    //   118: pop    //   119: aload 11    //   121: ldc_w 308    //   124: ldc_w 309    //   127: invokevirtual 306	java/util/Properties:setProperty	(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;    //   130: pop    //   131: bipush 60    //   133: invokestatic 310	java/sql/DriverManager:setLoginTimeout	(I)V    //   136: aload_1    //   137: invokevirtual 141	aip/migrate/AIPMigrateConfig:getDestURL	()Ljava/lang/String;    //   140: aload 11    //   142: invokestatic 311	java/sql/DriverManager:getConnection	(Ljava/lang/String;Ljava/util/Properties;)Ljava/sql/Connection;    //   145: astore 6    //   147: aload 6    //   149: sipush 1003    //   152: sipush 1008    //   155: invokeinterface 247 3 0    //   160: astore 8    //   162: aload_2    //   163: invokevirtual 136	aip/migrate/AIPMigrateXMLInfo:getTablename	()Ljava/lang/String;    //   166: invokestatic 113	aip/util/NVL:isEmpty	(Ljava/lang/String;)Z    //   169: ifne +92 -> 261    //   172: aload_1    //   173: invokevirtual 70	aip/migrate/AIPMigrateConfig:getDestDriver	()Ljava/lang/String;    //   176: aload_1    //   177: invokevirtual 141	aip/migrate/AIPMigrateConfig:getDestURL	()Ljava/lang/String;    //   180: aload_1    //   181: invokevirtual 142	aip/migrate/AIPMigrateConfig:getDestUser	()Ljava/lang/String;    //   184: aload_1    //   185: invokevirtual 143	aip/migrate/AIPMigrateConfig:getDestPass	()Ljava/lang/String;    //   188: aload_2    //   189: invokevirtual 136	aip/migrate/AIPMigrateXMLInfo:getTablename	()Ljava/lang/String;    //   192: aload_2    //   193: invokevirtual 312	aip/migrate/AIPMigrateXMLInfo:getDestClobClause	()Ljava/lang/String;    //   196: invokestatic 313	aip/db/AIPDBUtil:getDBTableCount	(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)J    //   199: lstore 12    //   201: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   204: new 9	java/lang/StringBuilder    //   207: dup    //   208: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   211: ldc 251    //   213: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   216: lload 12    //   218: invokevirtual 185	java/lang/StringBuilder:append	(J)Ljava/lang/StringBuilder;    //   221: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   224: invokevirtual 252	java/io/PrintStream:print	(Ljava/lang/String;)V    //   227: goto +34 -> 261    //   230: astore 12    //   232: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   235: new 9	java/lang/StringBuilder    //   238: dup    //   239: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   242: ldc 253    //   244: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   247: aload 12    //   249: invokevirtual 37	java/lang/Exception:getMessage	()Ljava/lang/String;    //   252: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   255: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   258: invokevirtual 22	java/io/PrintStream:println	(Ljava/lang/String;)V    //   261: iconst_0    //   262: istore 12    //   264: iconst_0    //   265: istore 13    //   267: aload_2    //   268: invokevirtual 268	aip/migrate/AIPMigrateXMLInfo:getTransferPrintLength	()I    //   271: istore 14    //   273: iload 14    //   275: ifle +12 -> 287    //   278: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   281: ldc_w 269    //   284: invokevirtual 252	java/io/PrintStream:print	(Ljava/lang/String;)V    //   287: new 9	java/lang/StringBuilder    //   290: dup    //   291: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   294: ldc_w 314    //   297: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   300: aload_2    //   301: invokevirtual 272	aip/migrate/AIPMigrateXMLInfo:getPk	()Ljava/lang/String;    //   304: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   307: ldc 237    //   309: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   312: aload_2    //   313: invokevirtual 315	aip/migrate/AIPMigrateXMLInfo:getSrcClobColumns	()[Ljava/lang/String;    //   316: ldc 237    //   318: invokestatic 238	aip/util/AIPUtil:joinSelectedIds	([Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/String;    //   321: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   324: ldc_w 316    //   327: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   330: aload_2    //   331: invokevirtual 136	aip/migrate/AIPMigrateXMLInfo:getTablename	()Ljava/lang/String;    //   334: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   337: ldc_w 317    //   340: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   343: aload_2    //   344: invokevirtual 272	aip/migrate/AIPMigrateXMLInfo:getPk	()Ljava/lang/String;    //   347: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   350: ldc_w 318    //   353: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   356: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   359: astore 15    //   361: new 9	java/lang/StringBuilder    //   364: dup    //   365: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   368: ldc_w 314    //   371: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   374: aload_2    //   375: invokevirtual 272	aip/migrate/AIPMigrateXMLInfo:getPk	()Ljava/lang/String;    //   378: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   381: ldc 237    //   383: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   386: aload_2    //   387: invokevirtual 319	aip/migrate/AIPMigrateXMLInfo:getDestClobColumns	()[Ljava/lang/String;    //   390: ldc 237    //   392: invokestatic 238	aip/util/AIPUtil:joinSelectedIds	([Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/String;    //   395: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   398: ldc_w 316    //   401: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   404: aload_2    //   405: invokevirtual 136	aip/migrate/AIPMigrateXMLInfo:getTablename	()Ljava/lang/String;    //   408: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   411: aload_2    //   412: invokevirtual 312	aip/migrate/AIPMigrateXMLInfo:getDestClobClause	()Ljava/lang/String;    //   415: invokestatic 113	aip/util/NVL:isEmpty	(Ljava/lang/String;)Z    //   418: ifeq +8 -> 426    //   421: ldc 74    //   423: goto +26 -> 449    //   426: new 9	java/lang/StringBuilder    //   429: dup    //   430: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   433: ldc_w 317    //   436: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   439: aload_2    //   440: invokevirtual 312	aip/migrate/AIPMigrateXMLInfo:getDestClobClause	()Ljava/lang/String;    //   443: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   446: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   449: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   452: aload_2    //   453: invokevirtual 320	aip/migrate/AIPMigrateXMLInfo:getDestdbtype	()I    //   456: iconst_1    //   457: if_icmpne +9 -> 466    //   460: ldc_w 321    //   463: goto +5 -> 468    //   466: ldc 74    //   468: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   471: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   474: astore 16    //   476: aload 6    //   478: iconst_0    //   479: invokeinterface 322 2 0    //   484: aload 8    //   486: bipush 60    //   488: invokeinterface 323 2 0    //   493: aload 8    //   495: aload 16    //   497: invokeinterface 274 2 0    //   502: astore 17    //   504: aload 17    //   506: invokeinterface 275 1 0    //   511: ifeq +208 -> 719    //   514: aload 17    //   516: aload_2    //   517: invokevirtual 272	aip/migrate/AIPMigrateXMLInfo:getPk	()Ljava/lang/String;    //   520: invokeinterface 324 2 0    //   525: lstore 18    //   527: aload 7    //   529: new 9	java/lang/StringBuilder    //   532: dup    //   533: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   536: aload 15    //   538: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   541: lload 18    //   543: invokevirtual 185	java/lang/StringBuilder:append	(J)Ljava/lang/StringBuilder;    //   546: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   549: invokeinterface 274 2 0    //   554: astore 20    //   556: aload 20    //   558: invokeinterface 275 1 0    //   563: ifeq +90 -> 653    //   566: iconst_0    //   567: istore 21    //   569: iload 21    //   571: aload_2    //   572: invokevirtual 319	aip/migrate/AIPMigrateXMLInfo:getDestClobColumns	()[Ljava/lang/String;    //   575: arraylength    //   576: if_icmpge +70 -> 646    //   579: aload 17    //   581: aload_2    //   582: invokevirtual 319	aip/migrate/AIPMigrateXMLInfo:getDestClobColumns	()[Ljava/lang/String;    //   585: iload 21    //   587: aaload    //   588: invokeinterface 325 2 0    //   593: astore 22    //   595: aload 20    //   597: aload_2    //   598: invokevirtual 315	aip/migrate/AIPMigrateXMLInfo:getSrcClobColumns	()[Ljava/lang/String;    //   601: iload 21    //   603: aaload    //   604: invokeinterface 325 2 0    //   609: astore 23    //   611: aload 23    //   613: invokestatic 326	aip/util/NVL:getStringClob	(Ljava/sql/Clob;)Ljava/lang/String;    //   616: astore 24    //   618: aload 24    //   620: aload_1    //   621: invokevirtual 281	aip/migrate/AIPMigrateConfig:getCnvCharsSrc	()Ljava/lang/String;    //   624: aload_1    //   625: invokevirtual 282	aip/migrate/AIPMigrateConfig:getCnvCharsDest	()Ljava/lang/String;    //   628: invokestatic 283	aip/util/AIPUtil:cnvCharsSrc2Dest	(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;    //   631: astore 24    //   633: aload 22    //   635: aload 24    //   637: invokestatic 327	aip/util/NVL:setStringClob	(Ljava/sql/Clob;Ljava/lang/String;)V    //   640: iinc 21 1    //   643: goto -74 -> 569    //   646: aload 17    //   648: invokeinterface 328 1 0    //   653: aload 20    //   655: invokeinterface 284 1 0    //   660: iinc 13 1    //   663: iload 14    //   665: ifle +51 -> 716    //   668: iload 13    //   670: ifle +46 -> 716    //   673: iload 13    //   675: iload 14    //   677: irem    //   678: ifne +38 -> 716    //   681: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   684: ldc 237    //   686: invokevirtual 252	java/io/PrintStream:print	(Ljava/lang/String;)V    //   689: iload 12    //   691: iload 13    //   693: iadd    //   694: istore 12    //   696: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   699: iload 12    //   701: invokevirtual 278	java/io/PrintStream:print	(I)V    //   704: iconst_0    //   705: istore 13    //   707: invokestatic 296	java/lang/System:gc	()V    //   710: invokestatic 297	java/lang/Runtime:getRuntime	()Ljava/lang/Runtime;    //   713: invokevirtual 298	java/lang/Runtime:gc	()V    //   716: goto -212 -> 504    //   719: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   722: ldc 237    //   724: invokevirtual 252	java/io/PrintStream:print	(Ljava/lang/String;)V    //   727: iload 12    //   729: iload 13    //   731: iadd    //   732: istore 12    //   734: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   737: iload 12    //   739: invokevirtual 278	java/io/PrintStream:print	(I)V    //   742: aload 6    //   744: invokeinterface 329 1 0    //   749: aload 6    //   751: iconst_1    //   752: invokeinterface 322 2 0    //   757: aload 17    //   759: invokeinterface 284 1 0    //   764: invokestatic 296	java/lang/System:gc	()V    //   767: invokestatic 297	java/lang/Runtime:getRuntime	()Ljava/lang/Runtime;    //   770: invokevirtual 298	java/lang/Runtime:gc	()V    //   773: goto +72 -> 845    //   776: astore 15    //   778: aload 15    //   780: invokevirtual 177	java/lang/Exception:printStackTrace	()V    //   783: aload_3    //   784: ifnull +31 -> 815    //   787: aload_3    //   788: new 9	java/lang/StringBuilder    //   791: dup    //   792: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   795: ldc_w 330    //   798: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   801: aload 15    //   803: invokevirtual 37	java/lang/Exception:getMessage	()Ljava/lang/String;    //   806: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   809: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   812: invokevirtual 22	java/io/PrintStream:println	(Ljava/lang/String;)V    //   815: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   818: new 9	java/lang/StringBuilder    //   821: dup    //   822: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   825: ldc_w 331    //   828: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   831: aload 15    //   833: invokevirtual 37	java/lang/Exception:getMessage	()Ljava/lang/String;    //   836: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   839: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   842: invokevirtual 22	java/io/PrintStream:println	(Ljava/lang/String;)V    //   845: jsr +84 -> 929    //   848: goto +192 -> 1040    //   851: astore 11    //   853: aload_3    //   854: ifnull +31 -> 885    //   857: aload_3    //   858: new 9	java/lang/StringBuilder    //   861: dup    //   862: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   865: ldc_w 330    //   868: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   871: aload 11    //   873: invokevirtual 37	java/lang/Exception:getMessage	()Ljava/lang/String;    //   876: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   879: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   882: invokevirtual 22	java/io/PrintStream:println	(Ljava/lang/String;)V    //   885: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   888: new 9	java/lang/StringBuilder    //   891: dup    //   892: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   895: ldc_w 332    //   898: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   901: aload 11    //   903: invokevirtual 37	java/lang/Exception:getMessage	()Ljava/lang/String;    //   906: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   909: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   912: invokevirtual 22	java/io/PrintStream:println	(Ljava/lang/String;)V    //   915: jsr +14 -> 929    //   918: goto +122 -> 1040    //   921: astore 25    //   923: jsr +6 -> 929    //   926: aload 25    //   928: athrow    //   929: astore 26    //   931: aload 9    //   933: ifnull +10 -> 943    //   936: aload 9    //   938: invokeinterface 284 1 0    //   943: aload 10    //   945: ifnull +10 -> 955    //   948: aload 10    //   950: invokeinterface 284 1 0    //   955: aload 7    //   957: ifnull +10 -> 967    //   960: aload 7    //   962: invokeinterface 259 1 0    //   967: aload 8    //   969: ifnull +10 -> 979    //   972: aload 8    //   974: invokeinterface 259 1 0    //   979: aload 5    //   981: ifnull +10 -> 991    //   984: aload 5    //   986: invokeinterface 300 1 0    //   991: aload 6    //   993: ifnull +10 -> 1003    //   996: aload 6    //   998: invokeinterface 300 1 0    //   1003: goto +35 -> 1038    //   1006: astore 27    //   1008: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   1011: new 9	java/lang/StringBuilder    //   1014: dup    //   1015: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   1018: ldc_w 332    //   1021: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   1024: aload 27    //   1026: invokevirtual 37	java/lang/Exception:getMessage	()Ljava/lang/String;    //   1029: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   1032: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   1035: invokevirtual 22	java/io/PrintStream:println	(Ljava/lang/String;)V    //   1038: ret 26    //   1040: new 163	java/util/Date    //   1043: dup    //   1044: invokespecial 164	java/util/Date:<init>	()V    //   1047: astore 11    //   1049: getstatic 8	java/lang/System:out	Ljava/io/PrintStream;    //   1052: new 9	java/lang/StringBuilder    //   1055: dup    //   1056: invokespecial 10	java/lang/StringBuilder:<init>	()V    //   1059: ldc_w 333    //   1062: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   1065: aload 11    //   1067: invokevirtual 182	java/util/Date:getTime	()J    //   1070: aload 4    //   1072: invokevirtual 182	java/util/Date:getTime	()J    //   1075: lsub    //   1076: ldc2_w 183    //   1079: ldiv    //   1080: invokevirtual 185	java/lang/StringBuilder:append	(J)Ljava/lang/StringBuilder;    //   1083: ldc 186    //   1085: invokevirtual 12	java/lang/StringBuilder:append	(Ljava/lang/String;)Ljava/lang/StringBuilder;    //   1088: invokevirtual 21	java/lang/StringBuilder:toString	()Ljava/lang/String;    //   1091: invokevirtual 22	java/io/PrintStream:println	(Ljava/lang/String;)V    //   1094: return    // Line number table:    //   Java source line #842	-> byte code offset #0    //   Java source line #843	-> byte code offset #9    //   Java source line #845	-> byte code offset #18    //   Java source line #846	-> byte code offset #24    //   Java source line #847	-> byte code offset #30    //   Java source line #852	-> byte code offset #36    //   Java source line #853	-> byte code offset #44    //   Java source line #854	-> byte code offset #61    //   Java source line #856	-> byte code offset #76    //   Java source line #857	-> byte code offset #84    //   Java source line #858	-> byte code offset #93    //   Java source line #859	-> byte code offset #106    //   Java source line #861	-> byte code offset #119    //   Java source line #862	-> byte code offset #131    //   Java source line #864	-> byte code offset #136    //   Java source line #866	-> byte code offset #147    //   Java source line #873	-> byte code offset #162    //   Java source line #875	-> byte code offset #172    //   Java source line #877	-> byte code offset #201    //   Java source line #880	-> byte code offset #227    //   Java source line #878	-> byte code offset #230    //   Java source line #879	-> byte code offset #232    //   Java source line #886	-> byte code offset #261    //   Java source line #887	-> byte code offset #264    //   Java source line #888	-> byte code offset #267    //   Java source line #889	-> byte code offset #273    //   Java source line #890	-> byte code offset #278    //   Java source line #899	-> byte code offset #287    //   Java source line #910	-> byte code offset #361    //   Java source line #923	-> byte code offset #476    //   Java source line #925	-> byte code offset #484    //   Java source line #927	-> byte code offset #493    //   Java source line #928	-> byte code offset #504    //   Java source line #930	-> byte code offset #514    //   Java source line #932	-> byte code offset #527    //   Java source line #934	-> byte code offset #556    //   Java source line #936	-> byte code offset #566    //   Java source line #937	-> byte code offset #579    //   Java source line #938	-> byte code offset #595    //   Java source line #940	-> byte code offset #611    //   Java source line #941	-> byte code offset #618    //   Java source line #944	-> byte code offset #633    //   Java source line #936	-> byte code offset #640    //   Java source line #947	-> byte code offset #646    //   Java source line #950	-> byte code offset #653    //   Java source line #952	-> byte code offset #660    //   Java source line #953	-> byte code offset #663    //   Java source line #954	-> byte code offset #681    //   Java source line #955	-> byte code offset #689    //   Java source line #956	-> byte code offset #696    //   Java source line #957	-> byte code offset #704    //   Java source line #959	-> byte code offset #707    //   Java source line #960	-> byte code offset #710    //   Java source line #963	-> byte code offset #716    //   Java source line #965	-> byte code offset #719    //   Java source line #966	-> byte code offset #727    //   Java source line #967	-> byte code offset #734    //   Java source line #969	-> byte code offset #742    //   Java source line #970	-> byte code offset #749    //   Java source line #972	-> byte code offset #757    //   Java source line #974	-> byte code offset #764    //   Java source line #975	-> byte code offset #767    //   Java source line #983	-> byte code offset #773    //   Java source line #977	-> byte code offset #776    //   Java source line #979	-> byte code offset #778    //   Java source line #980	-> byte code offset #783    //   Java source line #981	-> byte code offset #787    //   Java source line #982	-> byte code offset #815    //   Java source line #984	-> byte code offset #845    //   Java source line #1009	-> byte code offset #848    //   Java source line #984	-> byte code offset #851    //   Java source line #985	-> byte code offset #853    //   Java source line #986	-> byte code offset #857    //   Java source line #988	-> byte code offset #885    //   Java source line #990	-> byte code offset #915    //   Java source line #1009	-> byte code offset #918    //   Java source line #991	-> byte code offset #921    //   Java source line #992	-> byte code offset #931    //   Java source line #993	-> byte code offset #936    //   Java source line #994	-> byte code offset #943    //   Java source line #995	-> byte code offset #948    //   Java source line #996	-> byte code offset #955    //   Java source line #997	-> byte code offset #960    //   Java source line #998	-> byte code offset #967    //   Java source line #999	-> byte code offset #972    //   Java source line #1000	-> byte code offset #979    //   Java source line #1001	-> byte code offset #984    //   Java source line #1002	-> byte code offset #991    //   Java source line #1003	-> byte code offset #996    //   Java source line #1008	-> byte code offset #1003    //   Java source line #1004	-> byte code offset #1006    //   Java source line #1006	-> byte code offset #1008    //   Java source line #1008	-> byte code offset #1038    //   Java source line #1011	-> byte code offset #1040    //   Java source line #1012	-> byte code offset #1049    //   Java source line #1013	-> byte code offset #1094    // Local variable table:    //   start	length	slot	name	signature    //   0	1095	0	this	AIPMigrate    //   0	1095	1	config	AIPMigrateConfig    //   0	1095	2	migrateXMLInfo	AIPMigrateXMLInfo    //   0	1095	3	prntStream	PrintStream    //   16	1055	4	method_start	Date    //   19	966	5	srcCN	Connection    //   22	975	6	destCN	Connection    //   25	936	7	srcSTMT	Statement    //   28	945	8	destSTMT	Statement    //   31	906	9	srcRS	ResultSet    //   34	915	10	destRS	ResultSet    //   91	50	11	destCNinfo	Properties    //   851	51	11	e	Exception    //   1047	19	11	method_end	Date    //   199	18	12	tablecount	long    //   230	18	12	e	Exception    //   262	476	12	transfer_print_all	int    //   265	465	13	transfer_print_counter	int    //   271	405	14	transfer_print_length	int    //   359	178	15	srcClobQuery	String    //   776	56	15	e	Exception    //   474	22	16	destClobQuery4Update	String    //   502	256	17	rsDest	ResultSet    //   525	17	18	pk	long    //   554	100	20	rsSrc	ResultSet    //   567	74	21	i	int    //   593	41	22	destClob	java.sql.Clob    //   609	3	23	srcClob	java.sql.Clob    //   616	20	24	value	String    //   921	6	25	localObject1	Object    //   929	1	26	localObject2	Object    //   1006	19	27	e2	Exception    // Exception table:    //   from	to	target	type    //   172	227	230	java/lang/Exception    //   287	773	776	java/lang/Exception    //   36	845	851	java/lang/Exception    //   36	848	921	finally    //   851	918	921	finally    //   921	926	921	finally    //   931	1003	1006	java/lang/Exception  }    private void check_aipmigrate_config_exist_validate_or_create()    throws Exception  {    System.out.println("check_aipmigrate_config_exist_validate_or_create():start....");        File aipmigrate_config = new File(aipmigrate_config_filename);    if (aipmigrate_config.exists())    {      AIPMigrateConfig aipMigrateConfig = load_aipmigrate_config();            Connection cn = null;            Class.forName(aipMigrateConfig.getSrcDriver());      cn = DriverManager.getConnection(aipMigrateConfig.getSrcURL(), aipMigrateConfig.getSrcUser(), aipMigrateConfig.getSrcPass());      cn.close();            Class.forName(aipMigrateConfig.getDestDriver());      cn = DriverManager.getConnection(aipMigrateConfig.getDestURL(), aipMigrateConfig.getDestUser(), aipMigrateConfig.getDestPass());      cn.close();    }    else    {      create_aipmigrate_config();    }    System.out.println("check_aipmigrate_config_exist_validate_or_create():end.");  }    private AIPMigrateConfig load_aipmigrate_config()    throws Exception  {    FileInputStream istream = new FileInputStream(aipmigrate_config_filename);    InputStreamReader isr = new InputStreamReader(istream, "UTF-8");    Properties ps = new Properties();    ps.load(isr);        AIPMigrateConfig ent = new AIPMigrateConfig();    ent.setSrcDriver(ps.getProperty("srcDriver"));    ent.setSrcURL(ps.getProperty("srcURL"));    ent.setSrcUser(ps.getProperty("srcUser"));    ent.setSrcPass(ps.getProperty("srcPass"));    ent.setDestDriver(ps.getProperty("destDriver"));    ent.setDestURL(ps.getProperty("destURL"));    ent.setDestUser(ps.getProperty("destUser"));    ent.setDestPass(ps.getProperty("destPass"));    ent.setTransferPrintLength(NVL.getInt(ps.getProperty("transferPrintLength"), 100));        ent.setCnvCharsSrc(ps.getProperty("cnvCharsSrc", "٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹یک'\"\f"));    ent.setCnvCharsDest(ps.getProperty("cnvCharsDest", "01234567890123456789يك   "));    return ent;  }    private void create_aipmigrate_config()    throws Exception  {    File aipmigrate_config = new File(aipmigrate_config_filename);    PrintWriter pw = new PrintWriter(aipmigrate_config);    pw.println("srcDriver=com.mysql.jdbc.Driver");    pw.println("srcURL=jdbc:mysql://localhost:3306/aiplaw_nahad?characterEncoding=utf8");    pw.println("srcUser=root");    pw.println("srcPass=aippia");    pw.println("destDriver=oracle.jdbc.OracleDriver");    pw.println("destURL=jdbc:oracle:thin:@localhost:1521:orcl");    pw.println("destUser=aiplaw");    pw.println("destPass=aiplaw");    pw.println("transferPrintLength=100");    pw.println("cnvCharsSrc=٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹یک'\"\f");    pw.println("cnvCharsDest=01234567890123456789يك   ");    pw.close();        throw new AIPException("please edit " + aipmigrate_config_filename + " file and set correct src,dest connection information.");  }    private static AIPMigrateArgs parsMeigrateArgs(String[] args)  {    AIPMigrateArgs migrateArgs = new AIPMigrateArgs();    for (int i = 0; i < args.length; i++) {      if ((args[i].startsWith("-g")) || (args[i].startsWith("-generate")))      {        migrateArgs.setIsgenerate(true);        migrateArgs.setGenerate(args[(i + 1)]);      }      else if ((args[i].startsWith("-m")) || (args[i].startsWith("-migrate")))      {        migrateArgs.setIsmigrate(true);        migrateArgs.setMigrate(args[(i + 1)]);      }      else if ((args[i].startsWith("-v")) || (args[i].startsWith("-validate")))      {        migrateArgs.setIsvalidate(true);        migrateArgs.setValidate(args[(i + 1)]);      }      else if ((args[i].startsWith("-l")) || (args[i].startsWith("-logging")))      {        migrateArgs.setIslogging(true);        migrateArgs.setLogging(args[(i + 1)]);      }      else if ((args[i].startsWith("-p")) || (args[i].startsWith("-path")))      {        migrateArgs.setIspath(true);        migrateArgs.setPath(args[(i + 1)]);      }    }    return migrateArgs;  }    private File[] list_xmlfiles(String a_path, String xmlfiles_filter)  {    final String filter = xmlfiles_filter;    xmlfiles_filter = AIPUtil.replaceAllString(xmlfiles_filter, "%", "");    final String filter_without_star = xmlfiles_filter;    File path = new File(NVL.isEmpty(a_path) ? "." : a_path);    File[] files = path.listFiles(new FileFilter()    {      public boolean accept(File f)      {        if ((filter.endsWith("%")) && (f.getName().startsWith(filter_without_star)) && (f.getName().endsWith(".aipmigrate.xml"))) {          return true;        }        if ((filter.startsWith("%")) && (f.getName().endsWith(filter_without_star + ".aipmigrate.xml"))) {          return true;        }        return false;      }    });    Arrays.sort(files, new Comparator<File>()    {      public int compare(File o1, File o2)      {        return o1.getName().compareToIgnoreCase(o2.getName());      }    });    return files;  }    public static void main2(String[] args)  {    System.out.println("main():start...");    try    {      String sql = "delete from cmbasetabletype";            Class.forName("oracle.jdbc.OracleDriver");      Connection cn = DriverManager.getConnection("jdbc:oracle:thin:@192.168.0.11:1521:orcl", "aiplaw", "aiplaw");      Statement stmt = cn.createStatement();            stmt.execute(sql);      stmt.close();      cn.close();    }    catch (Exception e)    {      System.out.println("main2():exception=" + e.getMessage());      e.printStackTrace();    }    System.out.println("main():end.");  }}