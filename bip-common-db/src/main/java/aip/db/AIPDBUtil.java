package aip.db;import aip.util.AIPUtil;import aip.util.NVL;import org.apache.commons.dbcp.BasicDataSourceFactory;import javax.naming.*;import javax.sql.DataSource;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.sql.*;import java.util.*;public class AIPDBUtil{  public static final int DBTYPE_MYSQL = 0;  public static final int DBTYPE_ORACLE = 1;  public static final int DBTYPE_SQLSERVER = 2;  public static final int DBTYPE_OTHER = 100;    public static Connection getDBConnection(String srcDriver, String srcURL, String srcUser, String srcPass)    throws Exception  {    Connection cn;    try    {      Class.forName(srcDriver);      cn = DriverManager.getConnection(srcURL, srcUser, srcPass);    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    return cn;  }    public static List<AIPDBTable> getDBTables(Connection cn)    throws Exception  {    return getDBTables(cn, null);  }    public static List<AIPDBTable> getDBTables(String srcDriver, String srcURL, String srcUser, String srcPass)    throws Exception  {    return getDBTables(srcDriver, srcURL, srcUser, srcPass, null);  }    public static List<AIPDBTable> getDBTables(Connection cn, String tables_filter)    throws Exception  {    return getInstance()._getDBTables(cn, tables_filter);  }    public List<AIPDBTable> _getDBTables(Connection cn, String tables_filter)    throws Exception  {    List<AIPDBTable> tables = new ArrayList();    try    {      ResultSet rsTables = cn.getMetaData().getTables(cn.getCatalog(), null, tables_filter, new String[] { "TABLE" });      while (rsTables.next())      {        AIPDBTable table = new AIPDBTable();        table.setTablename(rsTables.getString("TABLE_NAME"));                ResultSet rsColumns = cn.getMetaData().getColumns(null, null, table.getTablename(), null);        while (rsColumns.next())        {          AIPDBColumn column = new AIPDBColumn();          column.setColumnname(rsColumns.getString("COLUMN_NAME"));          column.setColumntype(rsColumns.getString("TYPE_NAME"));          column.setColumnsize(rsColumns.getInt("COLUMN_SIZE"));          table.getColumns().add(column);        }        tables.add(table);                rsColumns.close();        rsColumns = null;      }      rsTables.close();      rsTables = null;    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    return tables;  }    public static List<AIPDBTable> getDBTables(String srcDriver, String srcURL, String srcUser, String srcPass, String tables_filter)    throws Exception  {    List<AIPDBTable> tables = new ArrayList();    Connection cn = null;    try    {      cn = getDBConnection(srcDriver, srcURL, srcUser, srcPass);      tables = getDBTables(cn, tables_filter);    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (cn != null) {        cn.close();      }      cn = null;    }    return tables;  }    public static String getInsertSQL(AIPDBTable table)  {    return getInsertSQL(table, 100);  }    public static String getInsertSQL(AIPDBTable table, int destinationDBType)  {    return getInstance()._getInsertSQL(table, destinationDBType);  }    public String _getInsertSQL(AIPDBTable table, int destinationDBType)  {    List<AIPDBColumn> columns = table.getColumns();        StringBuffer sb = new StringBuffer();    sb.append("insert into " + table.getTablename() + " (  ");    for (int i = 0; i < columns.size(); i++)    {      sb.append(((AIPDBColumn)columns.get(i)).getColumnname());      if (i != columns.size() - 1) {        sb.append(",");      }    }    sb.append(")");    sb.append("values (");    for (int i = 0; i < columns.size(); i++)    {      String prefixsuffix = "";      if (("VARCHAR".equalsIgnoreCase(((AIPDBColumn)columns.get(i)).getColumntype())) || ("CHAR".equalsIgnoreCase(((AIPDBColumn)columns.get(i)).getColumntype())) || ("CLOB".equalsIgnoreCase(((AIPDBColumn)columns.get(i)).getColumntype()))) {        prefixsuffix = "'";      }      String columntype = ((AIPDBColumn)columns.get(i)).getColumntype().toUpperCase();      if ((destinationDBType == 1) && ((columntype.indexOf("TEXT") > -1) || (columntype.indexOf("CLOB") > -1))) {        sb.append("EMPTY_CLOB()");      } else if ((destinationDBType == 1) && (columntype.indexOf("BLOB") > -1)) {        sb.append("EMPTY_BLOB()");      } else {        sb.append(prefixsuffix + ":" + ((AIPDBColumn)columns.get(i)).getColumnname() + prefixsuffix + " ");      }      if (i != columns.size() - 1) {        sb.append(",");      }    }    sb.append(")");    return sb.toString();  }    public static String getUpdateSQL(AIPDBTable table)  {    return getInstance()._getUpdateSQL(table);  }    public String _getUpdateSQL(AIPDBTable table)  {    List<AIPDBColumn> columns = table.getColumns();        StringBuffer sb = new StringBuffer();    sb.append("update  " + table.getTablename() + " set  ");    for (int i = 0; i < columns.size(); i++)    {      sb.append(((AIPDBColumn)columns.get(i)).getColumnname());      sb.append("=");      String prefixsuffix = "";      if (("VARCHAR".equalsIgnoreCase(((AIPDBColumn)columns.get(i)).getColumntype())) || ("CHAR".equalsIgnoreCase(((AIPDBColumn)columns.get(i)).getColumntype())) || ("CLOB".equalsIgnoreCase(((AIPDBColumn)columns.get(i)).getColumntype()))) {        prefixsuffix = "'";      }      sb.append(prefixsuffix + ":" + ((AIPDBColumn)columns.get(i)).getColumnname() + prefixsuffix + " ");      if (i != columns.size() - 1) {        sb.append(",");      }    }    sb.append(" where id=:id");    return sb.toString();  }    public static Collection<String> getDBTablePKs(Connection cn, String tablename, String pkfield)    throws Exception  {    return getInstance()._getDBTablePKs(cn, tablename, pkfield);  }    public Collection<String> _getDBTablePKs(Connection cn, String tablename, String pkfield)    throws Exception  {    Collection<String> col = new HashSet();        Statement stmt = null;    ResultSet rs = null;    String query = "select " + pkfield + " from " + tablename;    try    {      stmt = cn.createStatement();      rs = stmt.executeQuery(query);      while (rs.next()) {        col.add(rs.getString(1));      }    }    catch (Exception e)    {      System.out.println("AIPDBUtil.getDBTablePKs():query=" + query + ":extion=" + e.getMessage());      e.printStackTrace();      throw e;    }    finally    {      if (rs != null) {        rs.close();      }      if (stmt != null) {        stmt.close();      }      rs = null;stmt = null;    }    return col;  }    public static Collection<String> getDBTablePKs(String srcDriver, String srcURL, String srcUser, String srcPass, String tablename, String pkfield)    throws Exception  {    Collection<String> col = new HashSet();        Connection cn = null;    try    {      cn = getDBConnection(srcDriver, srcURL, srcUser, srcPass);      col = getDBTablePKs(cn, tablename, pkfield);    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (cn != null) {        cn.close();      }      cn = null;    }    return col;  }    public static long getDBTableCount(Connection cn, String tablename, String clause)    throws Exception  {    return getInstance()._getDBTableCount(cn, tablename, clause);  }    public long _getDBTableCount(Connection cn, String tablename, String clause)    throws Exception  {    long tablecount = 0L;    Statement stmt = null;    ResultSet rs = null;    String query = "select count(*) from " + tablename + (NVL.isEmpty(clause) ? "" : new StringBuilder().append(" where ").append(clause).toString());    try    {      stmt = cn.createStatement();      rs = stmt.executeQuery(query);      if (rs.next()) {        tablecount = rs.getLong(1);      }    }    catch (Exception e)    {      System.out.println("AIPDBUtil.getDBTableCount():query=" + query + ":extion=" + e.getMessage());      e.printStackTrace();      throw e;    }    finally    {      if (rs != null) {        rs.close();      }      if (stmt != null) {        stmt.close();      }      rs = null;stmt = null;    }    return tablecount;  }    public static long getDBTableCount(String srcDriver, String srcURL, String srcUser, String srcPass, String tablename, String clause)    throws Exception  {    long tablecount = 0L;    Connection cn = null;    try    {      cn = getDBConnection(srcDriver, srcURL, srcUser, srcPass);      tablecount = getDBTableCount(cn, tablename, clause);    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (cn != null) {        cn.close();      }      cn = null;    }    return tablecount;  }    private static DataSource _getDataSource(String dataSourceName)    throws Exception  {    Context ctx = new InitialContext();    try    {      Context ctx_comp_env = (Context)ctx.lookup("java:comp/env");      return (DataSource)ctx_comp_env.lookup(dataSourceName);    }    catch (NameNotFoundException ex) {}catch (Exception ex) {}    DataSource ds = (DataSource)ctx.lookup(dataSourceName);    return ds;  }    public static DataSource getDataSource(String dataSourceName)    throws Exception  {    try    {      return _getDataSource(dataSourceName);    }    catch (Exception e)    {      try      {        return getFSContextDataSource(dataSourceName);      }      catch (Exception e1)      {        try        {          return getBasicDataSource(dataSourceName);        }        catch (Exception e2)        {          e2.printStackTrace();          throw e;        }      }    }  }    private static DataSource getFSContextDataSource(String dataSourceName)    throws Exception  {    return getInstance()._getFSContextDataSource(dataSourceName);  }    private DataSource _getFSContextDataSource(String dataSourceName)    throws Exception  {    Hashtable<String, String> env = new Hashtable(11);    env.put("java.naming.factory.initial", "com.sun.jndi.fscontext.RefFSContextFactory");    env.put("java.naming.provider.url", "file:///tmp");    try    {      InitialContext ic = new InitialContext(env);      return (DataSource)ic.lookup(dataSourceName);    }    catch (NoInitialContextException e1)    {      throw e1;    }    catch (Exception e1)    {      InitialContext ic = new InitialContext(env);            Reference ref = new Reference("javax.sql.DataSource", "org.apache.commons.dbcp.BasicDataSourceFactory", null);            ref.add(new StringRefAddr("driverClassName", "oracle.jdbc.OracleDriver_shouldreplaced"));      ref.add(new StringRefAddr("url", "jdbc:oracle:thin:@127.0.0.1:1521:orcl_shouldreplaced"));      ref.add(new StringRefAddr("username", "user_shouldreplaced"));      ref.add(new StringRefAddr("password", "pass_shouldreplaced"));      ref.add(new StringRefAddr("accessToUnderlyingConnectionAllowed", "true"));      ref.add(new StringRefAddr("maxActive", "20"));      ref.add(new StringRefAddr("maxIdle", "10"));      ref.add(new StringRefAddr("maxWait", "-1"));      ic.rebind(dataSourceName + "_shouldreplaced", ref);      throw e1;    }  }    private static DataSource getBasicDataSource(String dataSourceName)    throws Exception  {    Properties cfg = readDataSourceConfigFile(dataSourceName);        return BasicDataSourceFactory.createDataSource(cfg);  }    private static Properties readDataSourceConfigFile(String dataSourceName)    throws Exception  {    dataSourceName = AIPUtil.replaceAllString(dataSourceName, "/", ".");    dataSourceName = AIPUtil.replaceAllString(dataSourceName, ":", "_");        Properties cfg = new Properties();    File f = new File(dataSourceName + ".cfg");        String exFillProperties = "ERROR: AIPDBUtil.getBasicDataSource: file:[" + f.getAbsolutePath() + "] was created.please fill connectivity information in it.";    if (f.exists())    {      FileInputStream fin = new FileInputStream(f);      cfg.load(fin);      if (NVL.isEmpty(cfg.getProperty("driverClassName"))) {        throw new Exception(exFillProperties);      }      return cfg;    }    cfg.setProperty("driverClassName", "");    cfg.setProperty("url", "");    cfg.setProperty("username", "");    cfg.setProperty("password", "");    cfg.setProperty("maxActive", "20");    cfg.setProperty("maxIdle", "10");    cfg.setProperty("maxWait", "-1");    cfg.setProperty("accessToUnderlyingConnectionAllowed", "false");        StringBuffer comment = new StringBuffer();    comment.append("AIPCo BasicDataSource properties file");    comment.append("\n oracle-driverClassName=oracle.jdbc.OracleDriver");    comment.append("\n oracle-url=jdbc:oracle:thin:@localhost:1521:orcl");    comment.append("\n oracle-accessToUnderlyingConnectionAllowed=true");    comment.append("\n mysql-driverClassName=com.mysql.jdbc.Driver");    comment.append("\n mysql-url=jdbc:mysql://localhost:3306/database?characterEncoding=utf8");    comment.append("\n sqlserver-driverClassName=com.microsoft.sqlserver.jdbc.SQLServerDriver");    comment.append("\n sqlserver-url=jdbc:sqlserver://192.168.0.71:1433;databaseName=aipsabtbidw;");    comment.append("\n olap-driverClassName=org.olap4j.driver.xmla.XmlaOlap4jDriver");    comment.append("\n olap-url=jdbc:xmla:Server=http://192.168.0.71:80/olap/msmdpump.dll;Catalog=NIOPDC_BI_Ver2");    comment.append("\n olap-accessToUnderlyingConnectionAllowed=true");    comment.append("\n access-driverClassName=sun.jdbc.odbc.JdbcOdbcDriver");    comment.append("\n access-url=jdbc:odbc:driver={Microsoft Access Driver (*.mdb)};DBQ=database_file");    comment.append("\n odbc-driverClassName=sun.jdbc.odbc.JdbcOdbcDriver");    comment.append("\n odbc-url=jdbc:odbc:dsn_source;");        cfg.store(new FileOutputStream(f), comment.toString());    throw new Exception(exFillProperties);  }    public static Connection getDataSourceConnection(String dataSourceName)    throws Exception  {    DataSource ds = getDataSource(dataSourceName);    return ds.getConnection();  }    public static Connection getDataSourceConnection(String dataSourceName, boolean forceCreateDataSource)    throws Exception  {    boolean existDataSource = false;    try    {      _getDataSource(dataSourceName);      existDataSource = true;    }    catch (Exception e) {}    if ((existDataSource) || (forceCreateDataSource)) {      return getDataSourceConnection(dataSourceName);    }    Properties cfg = readDataSourceConfigFile(dataSourceName);    Class.forName(cfg.getProperty("driverClassName"));    Connection cn = DriverManager.getConnection(cfg.getProperty("url"), cfg.getProperty("username"), cfg.getProperty("password"));        return cn;  }    public static Connection getDataSourceConnection(String dataSourceName, String username, String password)    throws Exception  {    DataSource ds = getDataSource(dataSourceName);    return ds.getConnection(username, password);  }    public static Object executeInsert(String dataSourceName, String sql, String sequenceName)    throws Exception  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return executeInsert(cn, sql, sequenceName);    }    catch (Exception e)    {      throw e;    }    finally    {      if (cn != null) {        cn.close();      }    }  }    public static Object executeInsert(Connection cn, String sql, String sequenceName)    throws Exception  {    String driverName = getDriverName(cn).toLowerCase();    if (driverName.indexOf("oracle") > -1) {      return executeInsertOracle(cn, sql, sequenceName);    }    if (driverName.indexOf("mysql") > -1) {      return executeInsertMysql(cn, sql);    }    if (driverName.indexOf("sql server") > -1) {      return executeInsertSqlserver(cn, sql);    }    throw new Exception("Driver " + driverName + " not defined for AIPDBUtil!");  }    public static Object executeInsertMysql(Connection cn, String sql)    throws Exception  {    return getInstance()._executeInsertMysql(cn, sql);  }    private Object _executeInsertMysql(Connection cn, String sql)    throws Exception  {    Statement stmt = null;    try    {      stmt = cn.createStatement();      stmt.execute(sql);      Object id = executeScalar(cn, "SELECT LAST_INSERT_ID()");      return id;    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      try      {        if (stmt != null) {          stmt.close();        }        stmt = null;      }      catch (Exception e)      {        e.printStackTrace();      }    }  }    public static Object executeInsertSqlserver(Connection cn, String sql)    throws Exception  {    return getInstance()._executeInsertSqlserver(cn, sql);  }    private Object _executeInsertSqlserver(Connection cn, String sql)    throws Exception  {    Statement stmt = null;    try    {      stmt = cn.createStatement();      stmt.execute(sql);      Object id = executeScalar(cn, "SELECT @@IDENTITY");      return id;    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (stmt != null) {        stmt.close();      }      stmt = null;    }  }    public static Object executeInsertOracle(Connection cn, String sql, String sequenceName)    throws Exception  {    return getInstance()._executeInsertOracle(cn, sql, sequenceName);  }    private Object _executeInsertOracle(Connection cn, String sql, String sequenceName)    throws Exception  {    Statement stmt = null;    try    {      stmt = cn.createStatement();      stmt.execute(sql);      Object id = null;      if (!NVL.isEmpty(sequenceName)) {        try        {          id = executeScalar(cn, "select " + sequenceName + ".CURRVAL from dual");        }        catch (Exception e)        {          e.printStackTrace();        }      }      return id;    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (stmt != null) {        stmt.close();      }      stmt = null;    }  }    public static void executeUpdate(String dataSourceName, String sql)    throws Exception  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      executeUpdate(cn, sql);    }    catch (Exception e)    {      throw e;    }    finally    {      if (cn != null) {        cn.close();      }      cn = null;    }  }    public static void executeUpdate(Connection cn, String sql)    throws Exception  {    Statement stmt = null;    try    {      stmt = cn.createStatement();      stmt.executeUpdate(sql);    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (stmt != null) {        stmt.close();      }      stmt = null;    }  }    public static Object executeScalar(String dataSourceName, String sql)    throws Exception  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return executeScalar(cn, sql);    }    catch (Exception e)    {      throw e;    }    finally    {      if (cn != null) {        cn.close();      }      cn = null;    }  }    public static Object executeScalar(Connection cn, String sql)    throws Exception  {    return getInstance()._executeScalar(cn, sql);  }    private Object _executeScalar(Connection cn, String sql)    throws Exception  {    Statement stmt = null;    ResultSet rs = null;    Object result = null;    try    {      stmt = cn.createStatement();      rs = stmt.executeQuery(sql);      if (rs.next()) {        result = rs.getObject(1);      }      return result;    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (rs != null) {        rs.close();      }      if (stmt != null) {        stmt.close();      }      rs = null;stmt = null;    }  }    public static ResultSet executeQuery2RS(String dataSourceName, String query)    throws Exception  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return executeQuery2RS(cn, query);    }    catch (Exception e)    {      throw e;    }    finally    {      if (cn != null) {        cn.close();      }      cn = null;    }  }    public static ResultSet executeQuery2RS(Connection cn, String query)    throws Exception  {    return getInstance()._executeQuery2RS(cn, query);  }    private ResultSet _executeQuery2RS(Connection cn, String query)    throws Exception  {    Statement stmt = null;    ResultSet result = null;    try    {      stmt = cn.createStatement();      result = stmt.executeQuery(query);      ResultSet localResultSet1 = result;return localResultSet1;    }    catch (Exception e)    {      e = e;      e.printStackTrace();      throw e;    }    finally {}  }    public static List<Object> executeQueryIds(String dataSourceName, String query)    throws Exception  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return executeQueryIds(cn, query);    }    catch (Exception e)    {      throw e;    }    finally    {      if (cn != null) {        cn.close();      }    }  }    public static List<Object> executeQueryIds(Connection cn, String query)    throws Exception  {    return getInstance()._executeQueryIds(cn, query);  }    private List<Object> _executeQueryIds(Connection cn, String query)    throws Exception  {    Statement stmt = null;    ResultSet rs = null;    List<Object> result = new ArrayList();    try    {      stmt = cn.createStatement();      rs = stmt.executeQuery(query);      while (rs.next()) {        result.add(rs.getObject(1));      }      return result;    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (rs != null) {        rs.close();      }      if (stmt != null) {        stmt.close();      }    }  }    public static Object[][] executeQuery(String dataSourceName, String query)    throws Exception  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return executeQuery(cn, query);    }    catch (Exception e)    {      throw e;    }    finally    {      if (cn != null) {        cn.close();      }    }  }    public static Object[][] executeQuery(Connection cn, String query)    throws Exception  {    return getInstance()._executeQuery(cn, query);  }    private Object[][] _executeQuery(Connection cn, String query)    throws Exception  {    Statement stmt = null;    ResultSet rs = null;    ArrayList<Object[]> result = new ArrayList();    try    {      stmt = cn.createStatement();      rs = stmt.executeQuery(query);      int n = rs.getMetaData().getColumnCount() + 1;      Object[] row;      while (rs.next())      {        row = new Object[n];        for (int i = 1; i < n; i++) {          row[i] = rs.getObject(i);        }        result.add(row);      }      return (Object[][])result.toArray(new Object[0][]);    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (rs != null) {        rs.close();      }      if (stmt != null) {        stmt.close();      }    }  }    public static AIPTableModel executeQuery2Table(String dataSourceName, String query)    throws Exception  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return executeQuery2Table(cn, query);    }    catch (Exception e)    {      throw e;    }    finally    {      if (cn != null) {        cn.close();      }    }  }    public static AIPTableModel executeQuery2Table(Connection cn, String query)    throws Exception  {    return getInstance()._executeQuery2Table(cn, query);  }    private AIPTableModel _executeQuery2Table(Connection cn, String query)    throws Exception  {    Statement stmt = null;    ResultSet rs = null;        AIPTableModel table = new AIPTableModel();    try    {      stmt = cn.createStatement();      rs = stmt.executeQuery(query);      ResultSetMetaData metaData = rs.getMetaData();      int totalColumn = metaData.getColumnCount();      Object[] dataRow = new Object[totalColumn];      int i;      if (rs != null)      {        for (i = 1; i <= totalColumn; i++) {          table.addColumn(metaData.getColumnName(i));        }        while (rs.next())        {          for (i = 1; i <= totalColumn; i++) {            dataRow[(i - 1)] = rs.getObject(i);          }          table.addRow(dataRow);        }      }      return table;    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (rs != null) {        rs.close();      }      if (stmt != null) {        stmt.close();      }    }  }    public static ResultSet executeQuery2RSPaging(String dataSourceName, String query, long firstrow, int pagesize)    throws Exception  {    return executeQuery2RSPaging(dataSourceName, query, "*", firstrow, pagesize);  }    public static ResultSet executeQuery2RSPaging(String dataSourceName, String query, String fields, long firstrow, int pagesize)    throws Exception  {    query = getQueryPaging(dataSourceName, query, fields, firstrow, pagesize);    return executeQuery2RS(dataSourceName, query);  }    public static ResultSet executeQuery2RSPaging(Connection cn, String query, long firstrow, int pagesize)    throws Exception  {    return executeQuery2RSPaging(cn, query, "*", firstrow, pagesize);  }    public static ResultSet executeQuery2RSPaging(Connection cn, String query, String fields, long firstrow, int pagesize)    throws Exception  {    query = getQueryPaging(cn, query, fields, firstrow, pagesize);    return executeQuery2RS(cn, query);  }    public static Object[][] executeQueryPaging(String dataSourceName, String query, long firstrow, int pagesize)    throws Exception  {    return executeQueryPaging(dataSourceName, query, "*", firstrow, pagesize);  }    public static Object[][] executeQueryPaging(String dataSourceName, String query, String fields, long firstrow, int pagesize)    throws Exception  {    query = getQueryPaging(dataSourceName, query, fields, firstrow, pagesize);    return executeQuery(dataSourceName, query);  }    public static Object[][] executeQueryPaging(Connection cn, String query, long firstrow, int pagesize)    throws Exception  {    return executeQueryPaging(cn, query, "*", firstrow, pagesize);  }    public static Object[][] executeQueryPaging(Connection cn, String query, String fields, long firstrow, int pagesize)    throws Exception  {    query = getQueryPaging(cn, query, fields, firstrow, pagesize);    return executeQuery(cn, query);  }    public static List<Object> executeQueryIdsPaging(String dataSourceName, String query, long firstrow, int pagesize)    throws Exception  {    return executeQueryIdsPaging(dataSourceName, query, "id", firstrow, pagesize);  }    public static List<Object> executeQueryIdsPaging(String dataSourceName, String query, String fields, long firstrow, int pagesize)    throws Exception  {    query = getQueryPaging(dataSourceName, query, fields, firstrow, pagesize);    return executeQueryIds(dataSourceName, query);  }    public static List<Object> executeQueryIdsPaging(Connection cn, String query, long firstrow, int pagesize)    throws Exception  {    return executeQueryIdsPaging(cn, query, "id", firstrow, pagesize);  }    public static List<Object> executeQueryIdsPaging(Connection cn, String query, String fields, long firstrow, int pagesize)    throws Exception  {    query = getQueryPaging(cn, query, fields, firstrow, pagesize);    return executeQueryIds(cn, query);  }    public static String getDriverName(Connection cn)  {    try    {      return cn.getMetaData().getDriverName();    }    catch (SQLException e)    {      e.printStackTrace();    }    return "";  }    public static String getDriverName(String dataSourceName)  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return getDriverName(cn);    }    catch (Exception e)    {      e.printStackTrace();    }    finally    {      try      {        if (cn != null) {          cn.close();        }      }      catch (Exception e2)      {        e2.printStackTrace();      }    }    return null;  }    public static String getQueryPaging(String dataSourceName, String query, long firstrow, int pagesize)  {    return getQueryPaging(dataSourceName, query, "*", firstrow, pagesize);  }    public static String getQueryPaging(String dataSourceName, String query, String fields, long firstrow, int pagesize)  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return getQueryPaging(cn, query, fields, firstrow, pagesize);    }    catch (Exception e)    {      e.printStackTrace();    }    finally    {      try      {        if (cn != null) {          cn.close();        }      }      catch (Exception e2) {}    }    return null;  }    public static String getQueryPaging(Connection cn, String fields, long firstrow, int pagesize)  {    return getQueryPaging(cn, "*", firstrow, pagesize);  }    public static String getQueryPaging(Connection cn, String query, String fields, long firstrow, int pagesize)  {    String driverName = getDriverName(cn).toLowerCase();    if (driverName.indexOf("oracle") > -1) {      query = getQueryPagingOracle(query, fields, firstrow, pagesize);    } else if (driverName.indexOf("mysql") > -1) {      query = getQueryPagingMysql(query, firstrow, pagesize);    } else if (driverName.indexOf("sql server") > -1) {      query = getQueryPagingMysql(query, firstrow, pagesize);    }    return query;  }    public static String getQueryPagingSqlserver(String query, long firstrow, int pagesize)  {    return query + " limit " + firstrow + "," + pagesize;  }    public static String getQueryPagingMysql(String query, long firstrow, int pagesize)  {    return query + " limit " + firstrow + "," + pagesize;  }    public static String getQueryPagingOracle(String query, long firstrow, int pagesize)  {    return getQueryPagingOracle(query, "*", firstrow, pagesize);  }    public static String getQueryPagingOracle(String query, String fields, long firstrow, int pagesize)  {    long lastrow = firstrow + pagesize;        StringBuffer sb = new StringBuffer();    sb.append("select ");    sb.append(fields);    sb.append(" from (select t1.*,rownum rnum from (\n");    sb.append(query);    sb.append("\n)t1 where rownum<");    sb.append(lastrow);    sb.append(")t2 where rnum>=");    sb.append(firstrow);        return sb.toString();  }    public static List<Object> getIds(String dataSourceName, String queryIds, AIPReportParam param)    throws Exception  {    Connection cn = null;    try    {      cn = getDataSourceConnection(dataSourceName);      return getIds(cn, queryIds, param);    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (cn != null) {        cn.close();      }    }  }    public static List<Object> getIds(Connection cn, String queryIds, AIPReportParam param)    throws Exception  {    List dto_ids = new ArrayList();    if (param.getPrintParam().getPrintRange() == 0)    {      int firstrow = (param.getRequestPage() - 1) * param.getPageSize();      dto_ids = executeQueryIdsPaging(cn, queryIds, firstrow, param.getPageSize());    }    else if (param.getPrintParam().getPrintRange() == 1)    {      dto_ids = executeQueryIds(cn, queryIds);    }    else    {      long[][] startsAndEnds = param.getPrintParam().getRequestStartsAndEnds(param.getPageSize());      for (int i = 0; i < startsAndEnds.length; i++)      {        List ids = executeQueryIdsPaging(cn, queryIds, startsAndEnds[i][0], (int)(startsAndEnds[i][1] - startsAndEnds[i][0] + 1L));                dto_ids.addAll(ids);      }    }    return dto_ids;  }    public static List getObjects(Class clazz, Connection cn, List ids, String tablename, String idfield, String[] columns)    throws Exception  {    return getObjects(clazz, cn, ids, tablename, idfield, columns, columns);  }    public static String getWhereClauseIdIN(List ids, String idfield)  {    return getInstance()._getWhereClauseIdIN(ids, idfield);  }    private String _getWhereClauseIdIN(List ids, String idfield)  {    StringBuffer whereClause = new StringBuffer();    whereClause.append(idfield);    whereClause.append(" in (");    for (int i = 0; i < ids.size(); i++)    {      whereClause.append(NVL.getString(ids.get(i)));      if (i != ids.size() - 1) {        whereClause.append(",");      }    }    if (ids.size() == 0) {      whereClause.append("0");    }    whereClause.append(" )");    return whereClause.toString();  }    public static List getObjects(Class clazz, Connection cn, List ids, String tablename, String idfield, String[] columns, String[] fields)    throws Exception  {    try    {      List dtos = new ArrayList();      StringBuffer query = new StringBuffer();      if (ids.size() > 0)      {        query.append("select * from ");        query.append(tablename);        query.append(getWhereClauseIdIN(ids, idfield));      }      return getObjects(clazz, cn, query.toString(), columns, fields);    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }  }    public static List getObjects(Class clazz, Connection cn, String query, String[] columns, String[] fields)    throws Exception  {    Statement stmt = null;    ResultSet rs = null;    try    {      List dtos = new ArrayList();            stmt = cn.createStatement();      rs = stmt.executeQuery(query);      Object obj;      while (rs.next())      {        obj = clazz.newInstance();        for (int j = 0; j < columns.length; j++) {          AIPUtil.invoke(obj, fields[j], rs.getObject(columns[j]));        }        dtos.add(obj);      }      return dtos;    }    catch (Exception e)    {      e.printStackTrace();      throw e;    }    finally    {      if (rs != null) {        rs.close();      }      if (stmt != null) {        stmt.close();      }    }  }    public static AIPDBUtil getInstance()  {    return new AIPDBUtil();  }    public static int executeBatch(Connection cn, String[] sql, boolean rollbackAll, String[] tableIds, String logTableIdName, String logExceptionSql, String logDescName)    throws Exception  {    int errorCounter = 0;    Statement stmt = null;    boolean autoCommit = cn.getAutoCommit();    try    {      cn.setAutoCommit(false);      stmt = cn.createStatement();      for (int i = 0; i < sql.length; i++) {        if (!NVL.isEmpty(sql[i])) {          stmt.addBatch(sql[i]);        }      }      stmt.executeBatch();            cn.commit();    }    catch (Exception e)    {      cn.rollback();      if (stmt != null)      {        stmt.close();        stmt = null;      }      e.printStackTrace();      if (!rollbackAll)      {        stmt = cn.createStatement();        for (int i = 0; i < sql.length; i++) {          try          {            if (!NVL.isEmpty(sql[i]))            {              stmt.execute(sql[i]);              cn.commit();            }          }          catch (Exception e2)          {            cn.rollback();            errorCounter++;            if (!NVL.isEmpty(logExceptionSql))            {              logExceptionSql = AIPUtil.replaceString(logExceptionSql, logTableIdName, tableIds[i]);              logExceptionSql = AIPUtil.replaceString(logExceptionSql, logDescName, AIPUtil.getExceptionAllMessages(e2));              try              {                stmt.executeUpdate(logExceptionSql);                cn.commit();              }              catch (Exception e3)              {                e3.printStackTrace();              }            }            else            {              throw new Exception(sql[i], e2);            }          }        }      }      else      {        errorCounter = sql.length;        if (!NVL.isEmpty(logExceptionSql))        {          logExceptionSql = AIPUtil.replaceString(logExceptionSql, logTableIdName, tableIds[0]);          logExceptionSql = AIPUtil.replaceString(logExceptionSql, logDescName, "<<rollbackAll>> :\n " + AIPUtil.getExceptionAllMessages(e));          try          {            stmt.executeUpdate(logExceptionSql);            cn.commit();          }          catch (Exception e3)          {            e3.printStackTrace();          }        }        else        {          throw new Exception(AIPUtil.mergeSelectedIds(sql, ";"), e);        }      }    }    finally    {      cn.setAutoCommit(autoCommit);      if (stmt != null) {        stmt.close();      }      stmt = null;    }    return errorCounter;  }    public static void main(String[] args) {}}