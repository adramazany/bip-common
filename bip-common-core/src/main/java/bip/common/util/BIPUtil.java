package bip.common.util;//import javax.servlet.http.HttpServletRequest;//import javax.servlet.http.HttpServletResponse;//import javax.servlet.jsp.PageContext;import aip.util.DateConvert;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.net.*;import java.security.MessageDigest;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.*;import java.util.regex.Matcher;import java.util.regex.Pattern;public class BIPUtil{  public static final int CNV_NONE = 0;  public static final int CNV_PARAM = 1;  public static final int CNV_ATTR = 2;  public static final int CNV_PARAM_ATTR = 3;  public static final int CNV_PARAM_ISO = 4;  public static final int CNV_ATTR_ISO = 5;  private static String _srcChars;  private static String _destChars;    public static Object invoke(Object obj, String field)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException  {    String field2invoke = field.substring(0, 1).toUpperCase() + field.substring(1);    Object v = obj.getClass().getMethod("get" + field2invoke, null).invoke(obj, null);    return v;  }    public static Object invokeMultiMethod(Object obj, String method)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException  {    Object v = null;    if (method.indexOf(".") > -1)    {      String[] ar = splitString(method, ".");      Object oo = obj;      for (int i = 0; i < ar.length; i++) {        oo = invokeMethod(oo, ar[i]);      }      v = oo;    }    else    {      v = invokeMethod(obj, method);    }    return v;  }    public static Object invokeMethod(Object obj, String method)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException  {    Object v = obj.getClass().getMethod(method, null).invoke(obj, null);    return v;  }    public static List exchangeList2Tree(List list, String pkField, String foriegnField, String childrenField)  {    try    {      Hashtable ht = new Hashtable();      for (int i = 0; i < list.size(); i++)      {        String key = "" + invoke(list.get(i), pkField);        ht.put(key, list.get(i));                List children = (List)invoke(list.get(i), childrenField);        children.clear();      }      for (int i = list.size() - 1; i >= 0; i--)      {        String keyParent = "" + invoke(list.get(i), foriegnField);        if (ht.containsKey(keyParent))        {          Object parent = ht.get(keyParent);          List children = (List)invoke(parent, childrenField);          children.add(list.get(i));          list.remove(i);        }      }      return list;    }    catch (IllegalArgumentException e)    {      e.printStackTrace();    }    catch (SecurityException e)    {      e.printStackTrace();    }    catch (IllegalAccessException e)    {      e.printStackTrace();    }    catch (InvocationTargetException e)    {      e.printStackTrace();    }    catch (NoSuchMethodException e)    {      e.printStackTrace();    }    return null;  }    public static void printObject(Object obj, boolean drillListFields, boolean drillObjectFields, boolean showFullName)  {    if (obj == null)    {      System.out.println("{null}\n");    }    else    {      StringBuffer sb = new StringBuffer();      printObject(obj, sb, 0, drillListFields, drillObjectFields, showFullName);      System.out.println(sb.toString() + "\n");    }  }    public static void printObject(Object obj)  {    printObject(obj, true, true, true);  }    public static void printObject(Object obj, StringBuffer sb, int level, boolean drillListFields, boolean drillObjectFields, boolean showFullName)  {    String tab = "";    for (int m = 0; m < level; m++) {      tab = tab + "\t";    }    if (level > 0) {      tab = tab + level + ".";    }    if (obj == null)    {      sb.append(tab + "{null}");      return;    }    if (((obj instanceof String)) || ((obj instanceof Integer)) || ((obj instanceof Double)))    {      sb.append(tab + "{" + obj.toString() + "}");      return;    }    if ((obj instanceof List))    {      List l = (List)obj;      sb.append("\n" + tab + obj.getClass().getName() + ";");      for (int j = 0; j < l.size(); j++)      {        sb.append("\n>>>");        printObject(l.get(j), sb, level + 1, drillListFields, drillObjectFields, showFullName);      }    }    else if (obj.getClass().isArray())    {      Object[] l = (Object[])obj;      sb.append("\n" + tab + obj.getClass().getName() + ";");      for (int j = 0; j < l.length; j++)      {        sb.append("\n>>>");        printObject(l[j], sb, level + 1, drillListFields, drillObjectFields, showFullName);      }    }    Class cls = obj.getClass();    ArrayList<Field> flds = new ArrayList();    while (cls != null)    {      Field[] fs = cls.getDeclaredFields();      for (int i = 0; i < fs.length; i++) {        flds.add(fs[i]);      }      cls = cls.getSuperclass();    }    sb.append(tab + obj.getClass().getSimpleName() + ":[");    for (int i = 0; i < flds.size(); i++)    {      String firstChar = ((Field)flds.get(i)).getName().substring(0, 1).toUpperCase();      String otherChars = ((Field)flds.get(i)).getName().substring(1);      String fld = firstChar + otherChars;      Object value = "";      try      {        value = invoke(obj, fld);      }      catch (Exception e)      {        value = "(err)";      }      if ((drillListFields) && ((value instanceof List)))      {        List l = (List)value;        if (l == null)        {          sb.append("\n>>>" + tab + ((Field)flds.get(i)).getName() + ":" + "{null};");        }        else        {          sb.append("\n>>>" + tab + ((Field)flds.get(i)).getName() + ":" + value.getClass().getSimpleName() + ";");          for (int j = 0; j < l.size(); j++)          {            sb.append("\n>>>");            printObject(l.get(j), sb, level + 1, drillListFields, drillObjectFields, showFullName);          }          sb.append("\n<<<");        }      }      else if ((drillObjectFields) && (!(value instanceof String)) && ((value instanceof Object)))      {        String pkg = value.getClass().getPackage().getName();        if (pkg.indexOf("aip") >= 0)        {          sb.append("\n>");          printObject(value, sb, level + 1, drillListFields, drillObjectFields, showFullName);        }        else        {          sb.append(((Field)flds.get(i)).getName() + "=" + value + ";");        }      }      else      {        sb.append(((Field)flds.get(i)).getName() + "=" + value + ";");      }    }    sb.append("]:fullName=" + obj.toString());  }    public static Integer[] splitString2Integer(String src, String delimeter)  {    String[] ar = src.split(delimeter);    Integer[] arInt = new Integer[ar.length];    for (int i = 0; i < ar.length; i++) {      if ((ar[i] != null) && (!"".equals(ar[i]))) {        try        {          Integer ii = Integer.valueOf(Integer.parseInt(ar[i]));          arInt[i] = ii;        }        catch (Exception ex) {}      }    }    return arInt;  }    public static String mergeInteger2String(Integer[] ar, String delimeter)  {    StringBuffer sb = new StringBuffer();    for (int i = 0; i < ar.length; i++) {      sb.append(ar[i] + delimeter);    }    return sb.toString();  }    public static Double[] splitString2Double(String src, String delimeter)  {    String[] ar = src.split(delimeter);    Double[] arInt = new Double[ar.length];    for (int i = 0; i < ar.length; i++) {      if ((ar[i] != null) && (!"".equals(ar[i]))) {        try        {          Double ii = Double.valueOf(Double.parseDouble(ar[i]));          arInt[i] = ii;        }        catch (Exception ex) {}      }    }    return arInt;  }    public static String mergeDouble2String(Double[] ar, String delimeter)  {    StringBuffer sb = new StringBuffer();    for (int i = 0; i < ar.length; i++) {      sb.append(ar[i] + delimeter);    }    return sb.toString();  }    public static String replace(String str, String pattern, String replace)  {    int s = 0;    int e = 0;    StringBuffer result = new StringBuffer();    while ((e = str.indexOf(pattern, s)) >= 0)    {      result.append(str.substring(s, e));      result.append(replace);      s = e + pattern.length();    }    result.append(str.substring(s));    return result.toString();  }    public static String replaceString(String src, String find, String replacement)  {    if ((src != null) && (!"".equals(src)) && (find != null))    {      int pos = src.indexOf(find);      if (pos >= 0) {        src = src.substring(0, pos) + replacement + src.substring(pos + find.length());      }    }    return src;  }    public static String replaceAllString(String src, String find, String replacement)  {    StringBuffer sb = new StringBuffer(src);    if ((src != null) && (!"".equals(src)) && (find != null))    {      int pos = sb.lastIndexOf(find);      while (pos >= 0)      {        sb.replace(pos, pos + find.length(), replacement);        pos = sb.lastIndexOf(find, pos - 1);      }    }    return sb.toString();  }    public static String truncate(String src, int length)  {    if ((src != null) && (src.length() > length)) {      src = src.substring(0, length) + "...";    }    return src;  }    public static void replaceString(StringBuffer src, String find, String replacement)  {    if ((src != null) && (find != null))    {      int pos = src.indexOf(find);      if (pos >= 0) {        src.replace(pos, pos + find.length(), replacement);      }    }  }    public static void replaceAllString(StringBuffer src, String find, String replacement)  {    if ((src != null) && (src.length() > 0) && (find != null) && (find.length() > 0))    {      int pos = src.length() + 1;      while (pos > -1)      {        pos = src.lastIndexOf(find, pos - 1);        if (pos > -1) {          src.replace(pos, pos + find.length(), replacement);        }      }    }  }    public static Object invokeMulti(Object obj, String field)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException  {    Object v = null;    if (field.indexOf(".") > -1)    {      String[] ar = splitString(field, ".");      Object oo = obj;      for (int i = 0; i < ar.length; i++) {        oo = invoke(oo, ar[i]);      }      v = oo;    }    else    {      v = invoke(obj, field);    }    return v;  }    public static String[] splitString(String src, String delimeter)  {    StringTokenizer tokenizer = new StringTokenizer(src, delimeter);    int n = tokenizer.countTokens();    String[] ar = new String[n];    for (int i = 0; i < n; i++) {      ar[i] = tokenizer.nextToken();    }    return ar;  }    public static Object invokeGetter(Object obj, String field)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException  {    Object v = obj.getClass().getMethod("get" + change2Capital(field), null).invoke(obj, null);    return v;  }    public static Object invokeSetter(Object obj, String field, String value)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException  {    Object v = obj.getClass().getMethod("set" + change2Capital(field), new Class[] { String.class }).invoke(obj, new Object[] { value });    return v;  }    public static List splitSelectedIdsArray(String selectedIds, String delimeter)  {    ArrayList<String> al = new ArrayList();    if (selectedIds != null)    {      String[] ar = selectedIds.split(delimeter);      for (int i = 0; i < ar.length; i++) {        if (!"".equals(ar[i].trim())) {          al.add(ar[i]);        }      }    }    return al;  }    public static String[] splitSelectedIds(String selectedIds, String delimeter)  {    return (String[])splitSelectedIdsArray(selectedIds, delimeter).toArray(new String[0]);  }    public static String mergeSelectedIds(String[] selectedIds, String delimeter)  {    StringBuffer sb = new StringBuffer();    for (int i = 0; i < selectedIds.length; i++)    {      sb.append(selectedIds[i]);      if (i + 1 < selectedIds.length) {        sb.append(delimeter);      }    }    return sb.toString();  }    public static String formatSelectedIds(String selectedIds)  {    return formatSelectedIds(selectedIds, ",");  }    public static String formatSelectedIds(String selectedIds, String delimeter)  {    return formatSelectedIds("", selectedIds, delimeter, "");  }    public static String formatSelectedIds(String prefix, String selectedIds, String delimeter, String suffix)  {    return prefix + mergeSelectedIds(splitSelectedIds(selectedIds, delimeter), delimeter) + suffix;  }    public static ArrayList<Field> getFields(Class cls)  {    ArrayList<Field> flds = new ArrayList();    while (cls != null)    {      Field[] fs = cls.getDeclaredFields();      for (int i = 0; i < fs.length; i++) {        flds.add(fs[i]);      }      cls = cls.getSuperclass();    }    return flds;  }    public static File createTempFile(String prefix, String suffix, File basePath, String webUserParam)    throws IOException  {    if (!basePath.exists())    {      boolean b = basePath.mkdirs();      if (!b) {        throw new IOException("اشکال در مسیر ایجاد فایلهای تبدیل شده!!!");      }    }    String username = "";    if (webUserParam != null) {      username = webUserParam + "-";    }    String dateTime = DateConvert.getTodayJalali().replaceAll("/", ".");    SimpleDateFormat sdf = new SimpleDateFormat("hh-mm-ss");    dateTime = dateTime + " " + sdf.format(new Date());        String fn = prefix + dateTime + "-" + username + Math.random() + suffix;    return new File(basePath, fn);  }  public static String getSystemCharset()  {    return System.getProperty("sun.jnu.encoding", System.getProperty("file.encoding", "UTF8"));  }    public static Properties loadResourceProperties(String resourceName)  {    ResourceBundle rb = ResourceBundle.getBundle(resourceName);    Properties result = new Properties();    for (Enumeration keys = rb.getKeys(); keys.hasMoreElements();)    {      String key = (String)keys.nextElement();      String value = rb.getString(key);            result.put(key, value);    }    return result;  }    public static Object getTypeValue(Class type, Object obj)  {    Object res = null;    if (type.isAssignableFrom(Integer.class)) {      return Integer.valueOf(NVL.getInt(obj));    }    if (type.isAssignableFrom(Double.class)) {      return Double.valueOf(NVL.getDbl(obj));    }    if (type.isAssignableFrom(Boolean.class)) {      return Boolean.valueOf(NVL.getBool(obj));    }    if (type.isAssignableFrom(Long.class)) {      return Long.valueOf(NVL.getLng(obj));    }    if (type.isAssignableFrom(String.class)) {      return NVL.getString(obj);    }    return null;  }    public static String change2Capital(String fieldName)  {    String firstChar = fieldName.substring(0, 1).toUpperCase();    String otherChars = fieldName.substring(1);    String fld = firstChar + otherChars;        return fld;  }    public static Object invoke(Object obj, String field, Object value)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, NoSuchFieldException  {    Class fieldType = null;    try    {      fieldType = obj.getClass().getDeclaredField(field).getType();    }    catch (NoSuchFieldException e)    {      fieldType = obj.getClass().getSuperclass().getDeclaredField(field).getType();    }    Object v = obj.getClass().getMethod("set" + change2Capital(field), new Class[] { fieldType }).invoke(obj, new Object[] { getTypeValue(fieldType, value) });    return v;  }    public static String joinSelectedIds(Object[] ids, String delimeter)  {    String res = "";    if (ids != null)    {      for (int i = 0; i < ids.length; i++) {        res = res + (ids[i] == null ? "" : new StringBuilder().append(ids[i]).append(delimeter).toString());      }      if (res.length() > 0) {        res = res.substring(0, res.length() - 1);      }    }    return res;  }    public static String convertToString(ArrayList ids)  {    String r = ",";    for (int i = 0; i < ids.size(); i++) {      r = r + ids.get(i) + ",";    }    return r;  }    public static SyncIds getSyncIds(String nids, String oids)  {    SyncIds sync = new SyncIds();        String[] newIds = getSyncIds(nids);    String[] oldIds = getSyncIds(oids);    Hashtable<String, String> ht = new Hashtable();        ArrayList<String> news = new ArrayList();    for (int i = 0; i < newIds.length; i++) {      if (NVL.getInt(newIds[i]) > 0) {        news.add(newIds[i]);      }    }    for (int i = 0; i < oldIds.length; i++) {      if (NVL.getInt(oldIds[i]) > 0) {        ht.put(oldIds[i], oldIds[i]);      }    }    for (int j = news.size() - 1; j >= 0; j--) {      if (ht.containsKey(news.get(j)))      {        ht.remove(news.get(j));        news.remove(j);      }      else if (NVL.getInt(news.get(j)) > 0)      {        sync.getNewIds().add(news.get(j));      }    }    Enumeration<String> enumtree = ht.elements();    while (enumtree.hasMoreElements())    {      String elm = (String)enumtree.nextElement();      if (NVL.getInt(elm) > 0) {        sync.getDelIds().add(elm);      }    }    return sync;  }    private static String[] getSyncIds(String ids)  {    String[] syncIds = splitter(NVL.getString(ids), ",");    for (int i = 0; i < syncIds.length; i++)    {      int pos = syncIds[i].indexOf(';');      if (pos > 0) {        syncIds[i] = splitter(syncIds[i], ";")[0];      }    }    return syncIds;  }    public static String[] splitter(String input, String delim)  {    Vector<String> v = new Vector();    StringTokenizer tokenizer = new StringTokenizer(input, delim, false);    while (tokenizer.hasMoreTokens()) {      v.addElement(tokenizer.nextToken());    }    String[] output = new String[v.size()];    for (int i = 0; i < v.size(); i++) {      output[i] = ((String)v.elementAt(i));    }    return output;  }    private static String cnvBIUniqueName2Client(String uniqueName)  {    if (uniqueName == null) {      return uniqueName;    }    String clientUniqueName = uniqueName;    clientUniqueName = replaceAllString(clientUniqueName, ".", "_dot_");    clientUniqueName = replaceAllString(clientUniqueName, "&", "_amp;");    return clientUniqueName;  }    private static String cnvBIUniqueName2Server(String clientUniqueName)  {    if (clientUniqueName == null) {      return clientUniqueName;    }    String uniqueName = clientUniqueName;    uniqueName = replaceAllString(uniqueName, "_dot_", ".");    uniqueName = replaceAllString(uniqueName, "_amp;", "&");    return uniqueName;  }    private static String[][] extractFunctionCallAndArguments1(String src, String functionName)  {    String patStr = functionName;    Pattern pattern = Pattern.compile(functionName);        Matcher matcher = pattern.matcher(src);        boolean found = false;    while (matcher.find())    {      System.out.format("I found the text \"%s\" starting at index %d and ending at index %d.%n", new Object[] { matcher.group(), Integer.valueOf(matcher.start()), Integer.valueOf(matcher.end()) });            found = true;    }    if (!found) {      System.out.println("No match found.%n");    }    return (String[][])null;  }    public static String[][] extractFunctionCallAndArguments(String src, String functionName)  {    if (src == null) {      return new String[0][0];    }    int startFunc = src.indexOf(functionName + "(");    ArrayList funcs = new ArrayList();    while (startFunc >= 0)    {      int endFunc = src.indexOf(")", startFunc + 1);      if (endFunc < 0) {        break;      }      String arg = src.substring(startFunc + functionName.length() + 1, endFunc);      String[] primary_args = arg.split(",");      ArrayList args = new ArrayList();      String tmpQueted = "";      for (int i = 0; i < primary_args.length; i++)      {        int startSingleQute = primary_args[i].indexOf("'");        int startDoubleQute = primary_args[i].indexOf("\"");        if ((startSingleQute >= 0) || (startDoubleQute >= 0))        {          if ((primary_args[i].indexOf("'", startSingleQute + 1) >= 0) || (primary_args[i].indexOf("\"", startDoubleQute + 1) >= 0))          {            args.add(primary_args[i]);          }          else if ("".equals(tmpQueted))          {            tmpQueted = primary_args[i];          }          else          {            tmpQueted = tmpQueted + "," + primary_args[i];            args.add(tmpQueted);            tmpQueted = "";          }        }        else if ("".equals(tmpQueted)) {          args.add(primary_args[i]);        } else {          tmpQueted = tmpQueted + "," + primary_args[i];        }      }      funcs.add((String[])args.toArray(new String[0]));            startFunc = src.indexOf(functionName + "(", endFunc + 1);    }    return (String[][])funcs.toArray(new String[0][0]);  }    public static String getExceptionAllMessages(Exception e)  {    if (e != null)    {      StringBuffer sb = new StringBuffer();      Throwable tr = e;      while (tr != null)      {        if ((tr.getCause() == null) || ((tr.getCause() != null) && (!tr.getCause().getClass().getName().equalsIgnoreCase(tr.getClass().getName()))))        {          sb.insert(0, "<br/>");          sb.insert(0, NVL.getString(tr.getMessage(), "خطای خالی (null) بودن مقادیر"));        }        tr = tr.getCause();      }      return sb.toString();    }    return "";  }  /*  public static String getAttributeOrParameter(HttpServletRequest request, String name)  {    return getAttributeOrParameter(request, name, false);  }    public static String getAttributeOrParameter(HttpServletRequest request, String name, boolean cnvParametr2Utf8)  {    return getAttributeOrParameter(request, name, cnvParametr2Utf8 ? 3 : 0);  }    public static String getAttributeOrParameter(HttpServletRequest request, String name, int cnvParametrOrAttribute2Utf8)  {    if (request.getAttribute(name) != null)    {      if ((cnvParametrOrAttribute2Utf8 == 2) || (cnvParametrOrAttribute2Utf8 == 3)) {        return UTF8.cnvUTF8(NVL.getString(request.getAttribute(name)));      }      if (cnvParametrOrAttribute2Utf8 == 5) {        return UTF8.cnvUTF8_ISO(NVL.getString(request.getAttribute(name)));      }      return request.getAttribute(name).toString();    }    if (request.getParameter(name) != null)    {      if ((cnvParametrOrAttribute2Utf8 == 1) || (cnvParametrOrAttribute2Utf8 == 3)) {        return UTF8.cnvUTF8(request.getParameter(name));      }      if (cnvParametrOrAttribute2Utf8 == 4) {        return UTF8.cnvUTF8_ISO(request.getParameter(name));      }      return request.getParameter(name);    }    return null;  }*/  public static Properties getPropertiesOfHTMLStyleString(String htmlStyleString)  {    Properties props = new Properties();    String[] items = splitSelectedIds(htmlStyleString, ";");    for (int i = 0; i < items.length; i++)    {      String[] pair = items[i].split(":");      if (pair.length > 1) {        props.put(pair[0].toLowerCase(), pair[1]);      } else {        props.put(pair[0].toLowerCase(), "");      }    }    return props;  }    public static String htmlToTXT(String src)  {    if (src == null) {      return src;    }    StringBuffer sbBr = new StringBuffer(src);        src = sbBr.toString();        StringBuffer sb = new StringBuffer();    StringBuffer digits = new StringBuffer();    int iter = 0;    int added = 0;        boolean hasTextHtmlTagToRemoveCrLFs = false;    while (iter < src.length()) {      if (src.charAt(iter) == '<')      {        hasTextHtmlTagToRemoveCrLFs = true;        if ((src.length() > iter + 1) && (src.charAt(iter + 1) == 'P'))        {          sb.append("[BR]");          added++;        }        else if ((src.length() > iter + 3) && (src.charAt(iter + 1) == 'D') && (src.charAt(iter + 2) == 'I') && (src.charAt(iter + 3) == 'V'))        {          sb.append("[BR]");          added++;        }        else if ((src.length() > iter + 2) && (src.charAt(iter + 1) == 'B') && (src.charAt(iter + 2) == 'R'))        {          sb.append("[BR]");          added++;        }        else if ((src.length() > iter + 5) && (src.charAt(iter + 1) == 'T') && (src.charAt(iter + 2) == 'A') && (src.charAt(iter + 3) == 'B') && (src.charAt(iter + 4) == 'L') && (src.charAt(iter + 5) == 'E'))        {          sb.append("[BR]");          added++;        }        else        {          while ((src.length() > iter + 5) && (src.charAt(iter + 1) == 'T') && (src.charAt(iter + 2) == 'I') && (src.charAt(iter + 3) == 'T') && (src.charAt(iter + 4) == 'L') && (src.charAt(iter + 5) == 'E') &&             (iter < src.length()) && (src.charAt(iter++) != '>')) {}        }        while ((iter < src.length()) && (src.charAt(iter++) != '>')) {}      }      else if ((src.charAt(iter) == '&') && (iter + 1 < src.length()) && (src.charAt(iter + 1) == '#'))      {        iter++;        iter++;        digits.delete(0, digits.length());        while ((iter < src.length()) && (src.charAt(iter) != ';'))        {          digits.append(src.charAt(iter));          iter++;        }        iter++;        char ch = (char)Integer.parseInt(digits.toString());        sb.append(ch);        added++;      }      else if ((src.charAt(iter) == '&') && (iter + 1 < src.length()) && ("abcdefghigklmnopqrstuvwxyz".indexOf(src.charAt(iter + 1)) >= 0))      {        while ((iter < src.length()) && (src.charAt(iter++) != ';')) {}      }      else      {        sb.append(src.charAt(iter++));        added++;      }    }    if (hasTextHtmlTagToRemoveCrLFs) {}    replaceAllString(sb, "[BR]", "\n");        return sb.toString();  }    private static ArrayList<String> textExratctQuotes(String text)  {    int first = 0;    int second = 0;    String subSt = "";    ArrayList<String> quotes = new ArrayList();    ArrayList<String> res = new ArrayList();    String[] ar = null;    while (first > -1)    {      first = text.indexOf("\"");      if (first > -1)      {        second = text.indexOf("\"", first + 1);        if (second < 0) {          second = text.length() - 1;        }        subSt = text.substring(first + 1, second);        if ((!"".equals(subSt)) && (!" ".equals(subSt))) {          quotes.add(subSt);        }        String st = text.substring(0, first);        if (second + 1 < text.length() - 1) {          st = st + text.substring(second + 1, text.length());        }        text = st;      }    }    ar = text.trim().split(" ");    for (int i = 0; i < ar.length; i++)    {      String st = ar[i].trim();      if ((!"".equals(st)) && (!" ".equals(st))) {        res.add(st);      }    }    for (int i = 0; i < quotes.size(); i++)    {      String st = (String)quotes.get(i);      res.add(st);    }    String st;    for (int i = 0; i < res.size(); i++) {      st = ((String)res.get(i)).trim();    }    return res;  }    public static ArrayList<String> splitSearchText(String text)  {    ArrayList<String> words = new ArrayList();    if (("".equals(text)) || (text == null)) {      return words;    }    text = text.trim();    words = textExratctQuotes(text);    return words;  }    public static SyncIdsResult syncNames(String newIdsStr, String oldIdsStr)  {    SyncIdsResult sync = new SyncIdsResult();        String[] newIds = splitSelectedIds(newIdsStr, ",");    String[] oldIds = splitSelectedIds(oldIdsStr, ",");    Hashtable<String, String> ht = new Hashtable();        ArrayList<String> news = new ArrayList();    for (int i = 0; i < newIds.length; i++) {      if (!NVL.isEmpty(newIds[i])) {        news.add(newIds[i]);      }    }    news = removeRepeated(news);    for (int i = 0; i < oldIds.length; i++) {      if (!NVL.isEmpty(oldIds[i])) {        ht.put(oldIds[i], oldIds[i]);      }    }    for (int j = news.size() - 1; j >= 0; j--) {      if (ht.containsKey(news.get(j)))      {        ht.remove(news.get(j));        news.remove(j);      }      else if (!NVL.isEmpty((String)news.get(j)))      {        sync.getNewIds().add(news.get(j));      }    }    Enumeration<String> enumtree = ht.elements();    while (enumtree.hasMoreElements())    {      String elm = (String)enumtree.nextElement();      if (!NVL.isEmpty(elm)) {        sync.getDelIds().add(elm);      }    }    return sync;  }    public static ArrayList<String> removeRepeated(ArrayList<String> list)  {    ArrayList<String> shortList = new ArrayList();    for (int i = 0; i < list.size(); i++) {      if (!shortList.contains(list.get(i))) {        shortList.add(list.get(i));      }    }    return shortList;  }    public static Object invokeMethod(Object obj, String method, Object... args)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException  {    Object v = obj.getClass().getMethod(method, null).invoke(obj, args);    return v;  }    public static Object invokeField(Object obj, String field)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchFieldException  {    Object v = obj.getClass().getField(field).get(obj);    return v;  }    public static String getDateOfDateTime(String dateTime)  {    String[] ar = dateTime.split(" ");    if (ar.length >= 1) {      return ar[0];    }    return "";  }    public static String getTimeOfDateTime(String dateTime)  {    String[] ar = dateTime.split(" ");    if (ar.length >= 2) {      return ar[1];    }    return "";  }    public static StringBuffer readResourceStream(Object _this, String path)    throws IOException  {    InputStream is = _this.getClass().getResourceAsStream(path);    byte[] buf = new byte[is.available()];    is.read(buf);    is.close();    return new StringBuffer(new String(buf, "UTF-8"));  }    public static StringBuffer readResourceStream(Class clazz, String path)    throws IOException  {    ClassLoader classLoader = clazz.getClassLoader();    InputStream in = classLoader.getResourceAsStream(path);    BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));        StringBuffer builder = new StringBuffer();    String aux = "";    while ((aux = reader.readLine()) != null) {      builder.append(aux);    }    in.close();        return builder;  }    public static String readFile(String path)    throws IOException  {    FileInputStream fis = new FileInputStream(path);    byte[] buf = new byte[fis.available()];    fis.read(buf);    fis.close();    return new String(buf, "UTF-8");  }    public static void writeFile(String path, String content)    throws IOException  {    FileOutputStream fos = new FileOutputStream(path);    fos.write(content.getBytes("UTF-8"));    fos.close();  }    public static byte[] readResourceStreamByte(Object _this, String path)    throws IOException  {    InputStream is = _this.getClass().getResourceAsStream(path);    byte[] buf = new byte[is.available()];    is.read(buf);    is.close();    return buf;  }    public static byte[] readFileByte(String path)    throws IOException  {    FileInputStream fis = new FileInputStream(path);    byte[] buf = new byte[fis.available()];    fis.read(buf);    fis.close();    return buf;  }    public static void writeFile(String path, byte[] content)    throws IOException  {    FileOutputStream fos = new FileOutputStream(path);    fos.write(content);    fos.close();  }    public static boolean isItemInItems(String item, String[] items)  {    if (item == null) {      return false;    }    for (int i = 0; i < items.length; i++) {      if (item.equalsIgnoreCase(items[i])) {        return true;      }    }    return false;  }    public static Object invoke(Object obj, String field, Class filedType, Object value)    throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException  {    Object v = obj.getClass().getMethod("set" + change2Capital(field), new Class[] { filedType }).invoke(obj, new Object[] { value });    return v;  }    public static String truncateHTML(String src, int length)  {    if (src == null) {      return src;    }    StringBuffer sbBr = new StringBuffer(src);        src = sbBr.toString();        StringBuffer sb = new StringBuffer();    int iter = 0;    int added = 0;    while ((added < length) && (iter < src.length())) {      if (src.charAt(iter) == '<')      {        while ((iter < src.length()) && (src.charAt(iter++) != '>')) {}      }      else      {        sb.append(src.charAt(iter++));        added++;      }    }    return sb.toString();  }    public static void cnvCorrectSolarDate(StringBuffer text)  {    cnvCorrectSolarDate(text, "[\\d]{1,2}/[\\d]{1,2}/[\\d]{4}");    cnvCorrectSolarDate(text, "[0-9۰-۹]{1,2}/[0-9۰-۹]{1,2}/[0-9۰-۹]{4}");  }    public static void cnvCorrectSolarDate(StringBuffer text, String pattern)  {    Pattern p = Pattern.compile(pattern);    Matcher m = p.matcher(text);    int start = 0;    while ((m.find(start)) && (start >= 0))    {      String found = text.substring(m.start(), m.end());      String[] ar = found.split("/");      String replacement = ar[2] + "/" + ar[1] + "/" + ar[0];      text.replace(m.start(), m.end(), replacement);            start = m.start() + 1;    }  }    public static void cnvCorrectMoney(StringBuffer text)  {    Pattern p = Pattern.compile("[\\d]{1,2}/[\\d]{1,2}/[\\d]{4}");    Matcher m = p.matcher(text);    int start = 0;    while ((m.find(start)) && (start >= 0))    {      System.out.println(m.start() + "," + m.end() + "," + text.substring(m.start(), m.end()));      String found = text.substring(m.start(), m.end());      String[] ar = found.split("/");      String replacement = ar[2] + "/" + ar[1] + "/" + ar[0];      text.replace(m.start(), m.end(), replacement);      System.out.println(m.start() + "," + m.end() + "," + text.substring(m.start(), m.end()));      start = m.start() + 1;    }  }    public static String cnvDigitEn2Fa(String text)  {    if (text == null) {      return text;    }    StringBuffer sb = new StringBuffer(text);    cnvDigitEn2Fa(sb);    return sb.toString();  }    public static void cnvDigitEn2Fa(StringBuffer sb)  {    String digitsEN = "0123456789";    String digitsFA = "٠١٢٣٤٥٦٧٨٩";    String digitsFA2 = "۰۱۲۳۴۵۶۷۸۹";    boolean insideTag = false;    for (int i = 0; i < sb.length(); i++)    {      char ch = sb.charAt(i);      if ((ch == '<') && (i + 1 < sb.length()) && (Character.isLetter(sb.charAt(i + 1))) && (!Character.isDigit(sb.charAt(i + 1)))) {        insideTag = true;      }      if (ch == '>') {        insideTag = false;      }      if ((ch >= '0') && (ch <= '9') && (!insideTag))      {        char ch_fa = digitsFA.charAt(ch - '0');        char ch_fa2 = digitsFA2.charAt(ch - '0');        sb.setCharAt(i, ch_fa2);      }    }  }    public static String cnvDigitFa2En(String text)  {    if (text == null) {      return text;    }    StringBuffer sb = new StringBuffer(text);    cnvDigitFa2En(sb);    return sb.toString();  }    public static void cnvDigitFa2En(StringBuffer sb)  {    String digitsEN = "0123456789";    String digitsFA1 = "٠١٢٣٤٥٦٧٨٩";    String digitsFA = "۰۱۲۳۴۵۶۷۸۹";    for (int i = 0; i < sb.length(); i++)    {      char ch = sb.charAt(i);      if ((ch >= '٠') && (ch <= '٩'))      {        char ch_fa = digitsEN.charAt(ch - '٠');        sb.setCharAt(i, ch_fa);      }      else if ((ch >= '۰') && (ch <= '۹'))      {        char ch_fa = digitsEN.charAt(ch - '۰');        sb.setCharAt(i, ch_fa);      }    }  }    public static String cnvTextCrlf2HtmlBR(String text)  {    if (text == null) {      return text;    }    if ((text.indexOf("<BODY") < 0) && (text.indexOf("<DIV") < 0)) {      text = ((text.indexOf("<div dir='rtl' id='firstDivRtl'>") < 0) && (text.indexOf("<div dir=\"rtl\" id=\"firstDivRtl\">") < 0) ? "<div dir='rtl' id='firstDivRtl'>" : "") + text + ((text.indexOf("<div dir='rtl' id='firstDivRtl'>") < 0) && (text.indexOf("<div dir=\"rtl\" id=\"firstDivRtl\">") < 0) ? "</div>" : "");    }    return cnvDigitEn2Fa(text);  }    public static String calculateSecurityHash(String stringInput, int length)  {    String decMessageEncode = calculateSecurityHash(stringInput);    if (decMessageEncode.length() > length) {      decMessageEncode = decMessageEncode.substring(0, length);    }    return decMessageEncode;  }    public static String calculateSecurityHash(String stringInput)  {    return calculateSecurityHash(stringInput, "MD5");  }    public static String calculateSecurityHash(String stringInput, String algorithm)  {    String hexMessageEncode = "";    try    {      byte[] buffer = stringInput.getBytes();      MessageDigest messageDigest = MessageDigest.getInstance(algorithm);      messageDigest.update(buffer, 0, buffer.length);      byte[] messageDigestBytes = messageDigest.digest(buffer);      for (int index = 0; index < messageDigestBytes.length; index++)      {        int countEncode = messageDigestBytes[index] & 0xFF;        if (Integer.toHexString(countEncode).length() == 1) {          hexMessageEncode = hexMessageEncode + "0";        }        hexMessageEncode = hexMessageEncode + Integer.toString(countEncode);      }    }    catch (Exception e)    {      e.printStackTrace();    }    return hexMessageEncode;  }    public static String cnvCharFaKY(String value)  {    return cnvCharsSrc2Dest(value, "یک", "يك");  }    public static String cnvCharsSrc2Dest(String value)  {    if (NVL.isEmpty(_srcChars)) {      _srcChars = System.getProperty("aip.charconvert.srcchars", "٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹یک");    }    if (NVL.isEmpty(_destChars)) {      _srcChars = System.getProperty("aip.charconvert.destchars", "01234567890123456789يك");    }    return cnvCharsSrc2Dest(value, _srcChars, _destChars);  }    public static String cnvCharsSrc2Dest(String value, String srcChars, String destChars)  {    if (NVL.isEmpty(value)) {      return value;    }    srcChars = NVL.getString(srcChars);    destChars = NVL.getString(destChars);    if (srcChars.length() != destChars.length()) {      throw new IllegalArgumentException("length of [srcChars] and [destChars] in BIPUtil.cnvCharsSrc2Dest does not match!");    }    if ((NVL.isEmpty(srcChars)) || (NVL.isEmpty(destChars))) {      return value;    }    StringBuffer sb = new StringBuffer(value);    for (int i = 0; i < sb.length(); i++)    {      char ch = sb.charAt(i);      for (int j = 0; j < srcChars.length(); j++) {        if (ch == srcChars.charAt(j)) {          sb.setCharAt(i, destChars.charAt(j));        }      }    }    return sb.toString();  }    public static ArrayList<ArrayList<String>> splitSearchSynonymsWords(String searchtext, String synonyms)  {    ArrayList<String> splited_text = splitSearchText(searchtext);    String[] splited_thesaurus = splitString(NVL.getString(synonyms), ";");        ArrayList<ArrayList<String>> synonyms_words = new ArrayList();    for (int i = 0; i < splited_text.size(); i++)    {      ArrayList<String> synonym_words = new ArrayList();      if ((splited_text.size() > i) && (splited_text.get(i) != null))      {        synonyms_words.add(synonym_words);        String mainword = (String)splited_text.get(i);                synonym_words.add(NVL.getString(mainword));        String word = "," + mainword + ",";        for (int j = 0; j < splited_thesaurus.length; j++) {          if (splited_thesaurus[j].indexOf(word) > -1)          {            String[] splited_synonyms = splitSelectedIds(splited_thesaurus[j], ",");            for (int k = 0; k < splited_synonyms.length; k++) {              if (!splited_synonyms[k].equalsIgnoreCase(mainword)) {                synonym_words.add(NVL.getString(splited_synonyms[k]));              }            }          }        }      }    }    return synonyms_words;  }    public static int countWord(String data, String word)  {    int counter = 0;    int pos = data.indexOf(word);    while (pos >= 0)    {      counter++;      pos = data.indexOf(word, pos + 1);    }    return counter;  }  /*  public static String getRequestFullAppPath(HttpServletRequest request)  {    String path;    try    {      path = org.apache.struts.util.RequestUtils.serverURL(request) + request.getContextPath() + "/";    }    catch (MalformedURLException e)    {      path = request.getScheme() + "://";      try      {        InetAddress addr = InetAddress.getByName(request.getRemoteAddr());        path = path + addr.getHostName();      }      catch (UnknownHostException e1)      {        path = path + request.getRemoteAddr();      }      if (!"80".equals(Integer.valueOf(request.getRemotePort()))) {        path = path + ":" + request.getRemotePort();      }      path = path + "/" + request.getContextPath() + "/";    }    return path;  }*//*  public static org.apache.struts.action.ActionForward forwardException(org.apache.struts.action.ActionMapping mapping, HttpServletRequest request, Exception e)  {    request.setAttribute("exception", e);    return mapping.findForward("aipexception");  }    public static org.apache.struts.action.ActionForward forwardExceptionMessage(org.apache.struts.action.ActionMapping mapping, HttpServletRequest request, Exception e)  {    request.setAttribute("exception", e);    return mapping.findForward("aipexceptionmessage");  }*/  public static String marksContentWords(String sectionText, String searchtext)  {    return marksContentWords(sectionText, splitSearchText(searchtext));  }    public static String marksContentWords(String sectionText, String searchtext, String styleClass)  {    return marksContentWords(sectionText, splitSearchText(searchtext), styleClass);  }    public static String marksContentWords(String sectionText, ArrayList<String> words)  {    return marksContentWords(sectionText, (String[])words.toArray(new String[0]), "redTextBox");  }    public static String marksContentWords(String sectionText, ArrayList<String> words, String styleClass)  {    return marksContentWords(sectionText, (String[])words.toArray(new String[0]), styleClass);  }    public static String marksContentWords(String sectionText, String[] words, String styleClass)  {    if ((sectionText == null) || ("".equals(sectionText.trim()))) {      return sectionText;    }    int foundCount = 0;    for (int i = 0; i < words.length; i++)    {      String st = words[i];      if (sectionText.indexOf(st) > -1)      {        foundCount++;        int stlen = st.length();        StringBuffer sb = new StringBuffer(sectionText);        int pos = sb.length();        while (pos > -1)        {          pos = sb.lastIndexOf(st, pos);          if (pos > -1)          {            sb.insert(pos + stlen, "</span>");            sb.insert(pos, "<span class='" + styleClass + "'>");          }        }        sectionText = sb.toString();      }    }    String foundedTxt = sectionText;    foundedTxt = sectionText;        return foundedTxt;  }  /*  public static void setOptionsCollection2Request(HttpServletRequest request, String name, String[][] label_value_collection)  {    List<org.apache.struts.util.LabelValueBean> col = new ArrayList();    if (label_value_collection != null) {      for (int i = 0; i < label_value_collection.length; i++) {        col.add(new org.apache.struts.util.LabelValueBean(label_value_collection[i][0], label_value_collection[i][1]));      }    }    request.setAttribute(name, col);  }    public static void forwardMessage(HttpServletResponse response, String text)  {    try    {      response.setCharacterEncoding("UTF-8");      response.setContentType("text/html;charset=UTF-8");      PrintWriter writer = response.getWriter();      writer.write(text);      writer.flush();    }    catch (IOException e)    {      e.printStackTrace();    }  }*//*  public static Object getAttributeAnyScope(PageContext pageContext, String name)  {    Object value = null;    int scope = pageContext.getAttributesScope(name);    if (scope > 0) {      value = pageContext.getAttribute(name, scope);    }    return value;  }*//*  public static String httpGet(String urlStr)    throws AIPException  {    return newInstance().httpGet(urlStr, null, null);  }    public String httpGet(String urlStr, String username, String password)    throws AIPException  {    BufferedReader in = null;    try    {      URL url = new URL(urlStr);      URLConnection cn = url.openConnection();      in = new BufferedReader(new InputStreamReader(cn.getInputStream()));            StringBuffer sb = new StringBuffer();      String inputLine;      while ((inputLine = in.readLine()) != null) {        sb.append(inputLine);      }      return sb.toString();    }    catch (MalformedURLException e)    {      throw new AIPException(e);    }    catch (IOException e)    {      throw new AIPException(e);    }    finally    {      if (in != null) {        try        {          in.close();        }        catch (IOException e)        {          e.printStackTrace();        }      }    }  }*/  public static BIPUtil newInstance()  {    return new BIPUtil();  }    public static int time2int_hhmmss(String time)  {    if (NVL.isEmpty(time)) {      return 0;    }    int time_int = 0;    if (time.indexOf(':') > -1)    {      time_int = NVL.getTimeInt(time, "00:00:00");    }    else    {      time = NVL.getStringFixLen(time, 6, '0');      time_int = NVL.getInt(time);    }    return time_int;  }    public static int time2second(String time)  {    int time_int = time2int_hhmmss(time);    int hour = time_int / 10000;    time_int %= 10000;    int minute = time_int / 100;    int second = time_int % 100;    return hour * 3600 + minute * 60 + second;  }    public static String getFileNameNoPath(String file)  {    int pos_slash = file.lastIndexOf('/');    if (pos_slash > -1) {      file = file.substring(pos_slash + 1);    }    int pos_backslash = file.lastIndexOf('\\');    if (pos_backslash > -1) {      file = file.substring(pos_backslash + 1);    }    return file;  }    public static String getFileNameNoPathNoExt(String file)  {    file = getFileNameNoPath(file);        int pos_dot = file.lastIndexOf('.');    if (pos_dot > -1) {      file = file.substring(0, pos_dot);    }    return file;  }    public static String timeAddSecond(String time, int second)    throws ParseException  {    return timeAddSecond(time2int_hhmmss(time), second);  }    public static String timeAddSecond(int time, int second)    throws ParseException  {    String myTime = NVL.getString(Integer.valueOf(time));    if (time < 10) {      myTime = "00000" + myTime;    } else if (time < 100) {      myTime = "0000" + myTime;    } else if (time < 1000) {      myTime = "000" + myTime;    } else if (time < 10000) {      myTime = "00" + myTime;    } else if (time < 100000) {      myTime = "0" + myTime;    }    SimpleDateFormat df = new SimpleDateFormat("HHmmss");    Date d = df.parse(myTime);    Calendar cal = Calendar.getInstance();    cal.setTime(d);    cal.add(13, second);        SimpleDateFormat df2 = new SimpleDateFormat("HH:mm:ss");    String newTime = df2.format(cal.getTime());        return newTime;  }    public static String timeDiff_hhmmss(String starttime, String endtime)    throws ParseException  {    SimpleDateFormat df2 = new SimpleDateFormat("HH:mm:ss");    int diff = timeDiff_second(starttime, endtime);    int hour = diff / 3600;    diff %= 3600;    int minute = diff / 60;    int second = diff % 60;    return String.format("%02d:%02d:%02d", new Object[] { Integer.valueOf(hour), Integer.valueOf(minute), Integer.valueOf(second) });  }    public static long timeDiff(String starttime, String endtime)    throws ParseException  {    starttime = timeAddSecond(starttime, 0);    endtime = timeAddSecond(endtime, 0);        SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss");    Date startdate = df.parse(starttime);    Date enddate = df.parse(endtime);        Calendar startcal = Calendar.getInstance();    startcal.setTime(startdate);    Calendar endcal = Calendar.getInstance();    endcal.setTime(enddate);        return endcal.getTimeInMillis() - startcal.getTimeInMillis();  }    public static int timeDiff_second(String starttime, String endtime)    throws ParseException  {    long timeDiff = timeDiff(starttime, endtime);    return (int)(timeDiff / 1000L);  }    public static void appendStringByPattern(StringBuffer sb, String pattern, String appendBeforePattern, String appendAfterPattern)  {    Pattern p = Pattern.compile(pattern);    Matcher m = p.matcher(sb);    int appendLength = appendBeforePattern.length() + appendAfterPattern.length();    int pos = 0;    while (m.find(pos))    {      sb.insert(m.end(), appendAfterPattern);      sb.insert(m.start(), appendBeforePattern);      pos = m.end() + 1 + appendLength;    }  }  /*  public static String digest(String src, String algorithm)    throws NoSuchAlgorithmException, UnsupportedEncodingException  {    MessageDigest messageDigest = MessageDigest.getInstance(algorithm);    messageDigest.reset();    messageDigest.update(src.getBytes("UTF8"));    byte[] resultByte = messageDigest.digest();    String result = new String(org.apache.commons.codec.binary.Hex.encodeHex(resultByte));    return result;  }*/  public static boolean existsURL(URL url)  {    boolean exists = false;    try    {      HttpURLConnection.setFollowRedirects(false);      HttpURLConnection con = (HttpURLConnection)url.openConnection();      con.setRequestMethod("HEAD");      exists = con.getResponseCode() == 200;    }    catch (Exception e) {}    return exists;  }    public static List<String> getWords(String st)  {    return getWords(st, 1, 0, null);  }    public static List<String> getWords(String st, String pattern)  {    return getWords(st, 1, 0, pattern);  }    public static List<String> getWords(String st, int minLen, String pattern)  {    return getWords(st, minLen, 0, pattern);  }    public static List<String> getWords(String st, int minLen, int maxLen, String pattern)  {    if (st == null) {      return null;    }    String[] ar = st.split("\\s+");    if (maxLen <= 0) {      maxLen = 2147483647;    }    if (minLen <= 0) {      minLen = 1;    }    ArrayList<String> list = new ArrayList();    for (int i = 0; i < ar.length; i++)    {      String word = ar[i];      if ((word.length() >= minLen) && (word.length() <= maxLen)) {        if (pattern != null)        {          if (word.matches(pattern)) {            list.add(word);          }        }        else {          list.add(word);        }      }    }    return list;  }    public static String removeHtmlTags(String st)  {    if (st == null) {      return st;    }    StringBuffer sb = new StringBuffer();        String[] ar = st.split("<(.+?)>");    for (int i = 0; i < ar.length; i++)    {      sb.append(ar[i]);            sb.append(" ");    }    return sb.toString();  }  public static String getExceptionAllMessages(Throwable t,String seperator) {    if (t == null) {      return "";    } else {      StringBuffer sb = new StringBuffer();      for(Object tr = t; tr != null; tr = ((Throwable)tr).getCause()) {        if (((Throwable)tr).getCause() == null || ((Throwable)tr).getCause() != null && !((Throwable)tr).getCause().getClass().getName().equalsIgnoreCase(tr.getClass().getName())) {          sb.insert(0, seperator);          sb.insert(0, NVL.getString(((Throwable)tr).getMessage(), "(NULL)"));        }      }      return sb.toString();    }  }}